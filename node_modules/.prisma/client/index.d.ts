
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model TravelTicket
 * 
 */
export type TravelTicket = $Result.DefaultSelection<Prisma.$TravelTicketPayload>
/**
 * Model Advance
 * 
 */
export type Advance = $Result.DefaultSelection<Prisma.$AdvancePayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Entitlement
 * 
 */
export type Entitlement = $Result.DefaultSelection<Prisma.$EntitlementPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model PayrollRun
 * 
 */
export type PayrollRun = $Result.DefaultSelection<Prisma.$PayrollRunPayload>
/**
 * Model PayrollItem
 * 
 */
export type PayrollItem = $Result.DefaultSelection<Prisma.$PayrollItemPayload>
/**
 * Model FinalSettlement
 * 
 */
export type FinalSettlement = $Result.DefaultSelection<Prisma.$FinalSettlementPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs>;

  /**
   * `prisma.travelTicket`: Exposes CRUD operations for the **TravelTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TravelTickets
    * const travelTickets = await prisma.travelTicket.findMany()
    * ```
    */
  get travelTicket(): Prisma.TravelTicketDelegate<ExtArgs>;

  /**
   * `prisma.advance`: Exposes CRUD operations for the **Advance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advances
    * const advances = await prisma.advance.findMany()
    * ```
    */
  get advance(): Prisma.AdvanceDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs>;

  /**
   * `prisma.entitlement`: Exposes CRUD operations for the **Entitlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entitlements
    * const entitlements = await prisma.entitlement.findMany()
    * ```
    */
  get entitlement(): Prisma.EntitlementDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.payrollRun`: Exposes CRUD operations for the **PayrollRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollRuns
    * const payrollRuns = await prisma.payrollRun.findMany()
    * ```
    */
  get payrollRun(): Prisma.PayrollRunDelegate<ExtArgs>;

  /**
   * `prisma.payrollItem`: Exposes CRUD operations for the **PayrollItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollItems
    * const payrollItems = await prisma.payrollItem.findMany()
    * ```
    */
  get payrollItem(): Prisma.PayrollItemDelegate<ExtArgs>;

  /**
   * `prisma.finalSettlement`: Exposes CRUD operations for the **FinalSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinalSettlements
    * const finalSettlements = await prisma.finalSettlement.findMany()
    * ```
    */
  get finalSettlement(): Prisma.FinalSettlementDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Employee: 'Employee',
    Contract: 'Contract',
    Leave: 'Leave',
    TravelTicket: 'TravelTicket',
    Advance: 'Advance',
    Asset: 'Asset',
    Attendance: 'Attendance',
    Entitlement: 'Entitlement',
    Document: 'Document',
    AuditLog: 'AuditLog',
    PayrollRun: 'PayrollRun',
    PayrollItem: 'PayrollItem',
    FinalSettlement: 'FinalSettlement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "employee" | "contract" | "leave" | "travelTicket" | "advance" | "asset" | "attendance" | "entitlement" | "document" | "auditLog" | "payrollRun" | "payrollItem" | "finalSettlement"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      TravelTicket: {
        payload: Prisma.$TravelTicketPayload<ExtArgs>
        fields: Prisma.TravelTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TravelTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TravelTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>
          }
          findFirst: {
            args: Prisma.TravelTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TravelTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>
          }
          findMany: {
            args: Prisma.TravelTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>[]
          }
          create: {
            args: Prisma.TravelTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>
          }
          createMany: {
            args: Prisma.TravelTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TravelTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>[]
          }
          delete: {
            args: Prisma.TravelTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>
          }
          update: {
            args: Prisma.TravelTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>
          }
          deleteMany: {
            args: Prisma.TravelTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TravelTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TravelTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TravelTicketPayload>
          }
          aggregate: {
            args: Prisma.TravelTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTravelTicket>
          }
          groupBy: {
            args: Prisma.TravelTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TravelTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TravelTicketCountArgs<ExtArgs>
            result: $Utils.Optional<TravelTicketCountAggregateOutputType> | number
          }
        }
      }
      Advance: {
        payload: Prisma.$AdvancePayload<ExtArgs>
        fields: Prisma.AdvanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>
          }
          findFirst: {
            args: Prisma.AdvanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>
          }
          findMany: {
            args: Prisma.AdvanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>[]
          }
          create: {
            args: Prisma.AdvanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>
          }
          createMany: {
            args: Prisma.AdvanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>[]
          }
          delete: {
            args: Prisma.AdvanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>
          }
          update: {
            args: Prisma.AdvanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>
          }
          deleteMany: {
            args: Prisma.AdvanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvancePayload>
          }
          aggregate: {
            args: Prisma.AdvanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvance>
          }
          groupBy: {
            args: Prisma.AdvanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvanceCountArgs<ExtArgs>
            result: $Utils.Optional<AdvanceCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Entitlement: {
        payload: Prisma.$EntitlementPayload<ExtArgs>
        fields: Prisma.EntitlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntitlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntitlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          findFirst: {
            args: Prisma.EntitlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntitlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          findMany: {
            args: Prisma.EntitlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>[]
          }
          create: {
            args: Prisma.EntitlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          createMany: {
            args: Prisma.EntitlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntitlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>[]
          }
          delete: {
            args: Prisma.EntitlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          update: {
            args: Prisma.EntitlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          deleteMany: {
            args: Prisma.EntitlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntitlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntitlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntitlementPayload>
          }
          aggregate: {
            args: Prisma.EntitlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntitlement>
          }
          groupBy: {
            args: Prisma.EntitlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntitlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntitlementCountArgs<ExtArgs>
            result: $Utils.Optional<EntitlementCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      PayrollRun: {
        payload: Prisma.$PayrollRunPayload<ExtArgs>
        fields: Prisma.PayrollRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>
          }
          findFirst: {
            args: Prisma.PayrollRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>
          }
          findMany: {
            args: Prisma.PayrollRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>[]
          }
          create: {
            args: Prisma.PayrollRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>
          }
          createMany: {
            args: Prisma.PayrollRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>[]
          }
          delete: {
            args: Prisma.PayrollRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>
          }
          update: {
            args: Prisma.PayrollRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>
          }
          deleteMany: {
            args: Prisma.PayrollRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollRunPayload>
          }
          aggregate: {
            args: Prisma.PayrollRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollRun>
          }
          groupBy: {
            args: Prisma.PayrollRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollRunCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollRunCountAggregateOutputType> | number
          }
        }
      }
      PayrollItem: {
        payload: Prisma.$PayrollItemPayload<ExtArgs>
        fields: Prisma.PayrollItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>
          }
          findFirst: {
            args: Prisma.PayrollItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>
          }
          findMany: {
            args: Prisma.PayrollItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>[]
          }
          create: {
            args: Prisma.PayrollItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>
          }
          createMany: {
            args: Prisma.PayrollItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>[]
          }
          delete: {
            args: Prisma.PayrollItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>
          }
          update: {
            args: Prisma.PayrollItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>
          }
          deleteMany: {
            args: Prisma.PayrollItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollItemPayload>
          }
          aggregate: {
            args: Prisma.PayrollItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollItem>
          }
          groupBy: {
            args: Prisma.PayrollItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollItemCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollItemCountAggregateOutputType> | number
          }
        }
      }
      FinalSettlement: {
        payload: Prisma.$FinalSettlementPayload<ExtArgs>
        fields: Prisma.FinalSettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinalSettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinalSettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>
          }
          findFirst: {
            args: Prisma.FinalSettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinalSettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>
          }
          findMany: {
            args: Prisma.FinalSettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>[]
          }
          create: {
            args: Prisma.FinalSettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>
          }
          createMany: {
            args: Prisma.FinalSettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinalSettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>[]
          }
          delete: {
            args: Prisma.FinalSettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>
          }
          update: {
            args: Prisma.FinalSettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>
          }
          deleteMany: {
            args: Prisma.FinalSettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinalSettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinalSettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalSettlementPayload>
          }
          aggregate: {
            args: Prisma.FinalSettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinalSettlement>
          }
          groupBy: {
            args: Prisma.FinalSettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinalSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinalSettlementCountArgs<ExtArgs>
            result: $Utils.Optional<FinalSettlementCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    contracts: number
    leaves: number
    travelTickets: number
    advances: number
    assets: number
    attendances: number
    entitlements: number
    documents: number
    payrollItems: number
    finalSettlements: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | EmployeeCountOutputTypeCountContractsArgs
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
    travelTickets?: boolean | EmployeeCountOutputTypeCountTravelTicketsArgs
    advances?: boolean | EmployeeCountOutputTypeCountAdvancesArgs
    assets?: boolean | EmployeeCountOutputTypeCountAssetsArgs
    attendances?: boolean | EmployeeCountOutputTypeCountAttendancesArgs
    entitlements?: boolean | EmployeeCountOutputTypeCountEntitlementsArgs
    documents?: boolean | EmployeeCountOutputTypeCountDocumentsArgs
    payrollItems?: boolean | EmployeeCountOutputTypeCountPayrollItemsArgs
    finalSettlements?: boolean | EmployeeCountOutputTypeCountFinalSettlementsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTravelTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TravelTicketWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAdvancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEntitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayrollItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollItemWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountFinalSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalSettlementWhereInput
  }


  /**
   * Count Type PayrollRunCountOutputType
   */

  export type PayrollRunCountOutputType = {
    items: number
  }

  export type PayrollRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PayrollRunCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PayrollRunCountOutputType without action
   */
  export type PayrollRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRunCountOutputType
     */
    select?: PayrollRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollRunCountOutputType without action
   */
  export type PayrollRunCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role: string | null
    employeeId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    role: string | null
    employeeId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    role: number
    employeeId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    employeeId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    employeeId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    role?: true
    employeeId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    role: string
    employeeId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    employeeId?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    employeeId?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    employeeId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      role: string
      employeeId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly employeeId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    employeeCode: string | null
    name: string | null
    nameEn: string | null
    nationalId: string | null
    email: string | null
    phone: string | null
    iqamaNumber: string | null
    iqamaExpiry: Date | null
    passportNumber: string | null
    passportExpiry: Date | null
    nationality: string | null
    bankName: string | null
    iban: string | null
    workPermitNumber: string | null
    workPermitExpiry: Date | null
    medicalInsuranceExpiry: Date | null
    joinDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    employeeCode: string | null
    name: string | null
    nameEn: string | null
    nationalId: string | null
    email: string | null
    phone: string | null
    iqamaNumber: string | null
    iqamaExpiry: Date | null
    passportNumber: string | null
    passportExpiry: Date | null
    nationality: string | null
    bankName: string | null
    iban: string | null
    workPermitNumber: string | null
    workPermitExpiry: Date | null
    medicalInsuranceExpiry: Date | null
    joinDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeCode: number
    name: number
    nameEn: number
    nationalId: number
    email: number
    phone: number
    iqamaNumber: number
    iqamaExpiry: number
    passportNumber: number
    passportExpiry: number
    nationality: number
    bankName: number
    iban: number
    workPermitNumber: number
    workPermitExpiry: number
    medicalInsuranceExpiry: number
    joinDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeCode?: true
    name?: true
    nameEn?: true
    nationalId?: true
    email?: true
    phone?: true
    iqamaNumber?: true
    iqamaExpiry?: true
    passportNumber?: true
    passportExpiry?: true
    nationality?: true
    bankName?: true
    iban?: true
    workPermitNumber?: true
    workPermitExpiry?: true
    medicalInsuranceExpiry?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeCode?: true
    name?: true
    nameEn?: true
    nationalId?: true
    email?: true
    phone?: true
    iqamaNumber?: true
    iqamaExpiry?: true
    passportNumber?: true
    passportExpiry?: true
    nationality?: true
    bankName?: true
    iban?: true
    workPermitNumber?: true
    workPermitExpiry?: true
    medicalInsuranceExpiry?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeCode?: true
    name?: true
    nameEn?: true
    nationalId?: true
    email?: true
    phone?: true
    iqamaNumber?: true
    iqamaExpiry?: true
    passportNumber?: true
    passportExpiry?: true
    nationality?: true
    bankName?: true
    iban?: true
    workPermitNumber?: true
    workPermitExpiry?: true
    medicalInsuranceExpiry?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    employeeCode: string | null
    name: string
    nameEn: string | null
    nationalId: string
    email: string | null
    phone: string | null
    iqamaNumber: string | null
    iqamaExpiry: Date | null
    passportNumber: string | null
    passportExpiry: Date | null
    nationality: string | null
    bankName: string | null
    iban: string | null
    workPermitNumber: string | null
    workPermitExpiry: Date | null
    medicalInsuranceExpiry: Date | null
    joinDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    name?: boolean
    nameEn?: boolean
    nationalId?: boolean
    email?: boolean
    phone?: boolean
    iqamaNumber?: boolean
    iqamaExpiry?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    nationality?: boolean
    bankName?: boolean
    iban?: boolean
    workPermitNumber?: boolean
    workPermitExpiry?: boolean
    medicalInsuranceExpiry?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    travelTickets?: boolean | Employee$travelTicketsArgs<ExtArgs>
    advances?: boolean | Employee$advancesArgs<ExtArgs>
    assets?: boolean | Employee$assetsArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    entitlements?: boolean | Employee$entitlementsArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    payrollItems?: boolean | Employee$payrollItemsArgs<ExtArgs>
    finalSettlements?: boolean | Employee$finalSettlementsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    name?: boolean
    nameEn?: boolean
    nationalId?: boolean
    email?: boolean
    phone?: boolean
    iqamaNumber?: boolean
    iqamaExpiry?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    nationality?: boolean
    bankName?: boolean
    iban?: boolean
    workPermitNumber?: boolean
    workPermitExpiry?: boolean
    medicalInsuranceExpiry?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeCode?: boolean
    name?: boolean
    nameEn?: boolean
    nationalId?: boolean
    email?: boolean
    phone?: boolean
    iqamaNumber?: boolean
    iqamaExpiry?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    nationality?: boolean
    bankName?: boolean
    iban?: boolean
    workPermitNumber?: boolean
    workPermitExpiry?: boolean
    medicalInsuranceExpiry?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    travelTickets?: boolean | Employee$travelTicketsArgs<ExtArgs>
    advances?: boolean | Employee$advancesArgs<ExtArgs>
    assets?: boolean | Employee$assetsArgs<ExtArgs>
    attendances?: boolean | Employee$attendancesArgs<ExtArgs>
    entitlements?: boolean | Employee$entitlementsArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    user?: boolean | Employee$userArgs<ExtArgs>
    payrollItems?: boolean | Employee$payrollItemsArgs<ExtArgs>
    finalSettlements?: boolean | Employee$finalSettlementsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      travelTickets: Prisma.$TravelTicketPayload<ExtArgs>[]
      advances: Prisma.$AdvancePayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      entitlements: Prisma.$EntitlementPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      payrollItems: Prisma.$PayrollItemPayload<ExtArgs>[]
      finalSettlements: Prisma.$FinalSettlementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeCode: string | null
      name: string
      nameEn: string | null
      nationalId: string
      email: string | null
      phone: string | null
      iqamaNumber: string | null
      iqamaExpiry: Date | null
      passportNumber: string | null
      passportExpiry: Date | null
      nationality: string | null
      bankName: string | null
      iban: string | null
      workPermitNumber: string | null
      workPermitExpiry: Date | null
      medicalInsuranceExpiry: Date | null
      joinDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contracts<T extends Employee$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany"> | Null>
    travelTickets<T extends Employee$travelTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$travelTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "findMany"> | Null>
    advances<T extends Employee$advancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$advancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Employee$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    attendances<T extends Employee$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany"> | Null>
    entitlements<T extends Employee$entitlementsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$entitlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Employee$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Employee$userArgs<ExtArgs> = {}>(args?: Subset<T, Employee$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payrollItems<T extends Employee$payrollItemsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payrollItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findMany"> | Null>
    finalSettlements<T extends Employee$finalSettlementsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$finalSettlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly employeeCode: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly nameEn: FieldRef<"Employee", 'String'>
    readonly nationalId: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly iqamaNumber: FieldRef<"Employee", 'String'>
    readonly iqamaExpiry: FieldRef<"Employee", 'DateTime'>
    readonly passportNumber: FieldRef<"Employee", 'String'>
    readonly passportExpiry: FieldRef<"Employee", 'DateTime'>
    readonly nationality: FieldRef<"Employee", 'String'>
    readonly bankName: FieldRef<"Employee", 'String'>
    readonly iban: FieldRef<"Employee", 'String'>
    readonly workPermitNumber: FieldRef<"Employee", 'String'>
    readonly workPermitExpiry: FieldRef<"Employee", 'DateTime'>
    readonly medicalInsuranceExpiry: FieldRef<"Employee", 'DateTime'>
    readonly joinDate: FieldRef<"Employee", 'DateTime'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.contracts
   */
  export type Employee$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Employee.travelTickets
   */
  export type Employee$travelTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    where?: TravelTicketWhereInput
    orderBy?: TravelTicketOrderByWithRelationInput | TravelTicketOrderByWithRelationInput[]
    cursor?: TravelTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TravelTicketScalarFieldEnum | TravelTicketScalarFieldEnum[]
  }

  /**
   * Employee.advances
   */
  export type Employee$advancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    where?: AdvanceWhereInput
    orderBy?: AdvanceOrderByWithRelationInput | AdvanceOrderByWithRelationInput[]
    cursor?: AdvanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvanceScalarFieldEnum | AdvanceScalarFieldEnum[]
  }

  /**
   * Employee.assets
   */
  export type Employee$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Employee.attendances
   */
  export type Employee$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee.entitlements
   */
  export type Employee$entitlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    cursor?: EntitlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Employee.documents
   */
  export type Employee$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Employee.user
   */
  export type Employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.payrollItems
   */
  export type Employee$payrollItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    where?: PayrollItemWhereInput
    orderBy?: PayrollItemOrderByWithRelationInput | PayrollItemOrderByWithRelationInput[]
    cursor?: PayrollItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollItemScalarFieldEnum | PayrollItemScalarFieldEnum[]
  }

  /**
   * Employee.finalSettlements
   */
  export type Employee$finalSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    where?: FinalSettlementWhereInput
    orderBy?: FinalSettlementOrderByWithRelationInput | FinalSettlementOrderByWithRelationInput[]
    cursor?: FinalSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalSettlementScalarFieldEnum | FinalSettlementScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    salary: number | null
    leaveDays: number | null
    leaveMoney: number | null
    probationDays: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
  }

  export type ContractSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    salary: number | null
    leaveDays: number | null
    leaveMoney: number | null
    probationDays: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    startDate: Date | null
    endDate: Date | null
    salary: number | null
    leaveDays: number | null
    leaveMoney: number | null
    contractType: string | null
    probationDays: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
  }

  export type ContractMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    startDate: Date | null
    endDate: Date | null
    salary: number | null
    leaveDays: number | null
    leaveMoney: number | null
    contractType: string | null
    probationDays: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    employeeId: number
    startDate: number
    endDate: number
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: number
    probationDays: number
    basicSalary: number
    housingAllow: number
    transportAllow: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    id?: true
    employeeId?: true
    salary?: true
    leaveDays?: true
    leaveMoney?: true
    probationDays?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
  }

  export type ContractSumAggregateInputType = {
    id?: true
    employeeId?: true
    salary?: true
    leaveDays?: true
    leaveMoney?: true
    probationDays?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    salary?: true
    leaveDays?: true
    leaveMoney?: true
    contractType?: true
    probationDays?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    salary?: true
    leaveDays?: true
    leaveMoney?: true
    contractType?: true
    probationDays?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    salary?: true
    leaveDays?: true
    leaveMoney?: true
    contractType?: true
    probationDays?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: number
    employeeId: number
    startDate: Date
    endDate: Date | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    leaveDays?: boolean
    leaveMoney?: boolean
    contractType?: boolean
    probationDays?: boolean
    basicSalary?: boolean
    housingAllow?: boolean
    transportAllow?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    leaveDays?: boolean
    leaveMoney?: boolean
    contractType?: boolean
    probationDays?: boolean
    basicSalary?: boolean
    housingAllow?: boolean
    transportAllow?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    leaveDays?: boolean
    leaveMoney?: boolean
    contractType?: boolean
    probationDays?: boolean
    basicSalary?: boolean
    housingAllow?: boolean
    transportAllow?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      startDate: Date
      endDate: Date | null
      salary: number
      leaveDays: number
      leaveMoney: number
      contractType: string
      probationDays: number | null
      basicSalary: number | null
      housingAllow: number | null
      transportAllow: number | null
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'Int'>
    readonly employeeId: FieldRef<"Contract", 'Int'>
    readonly startDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly salary: FieldRef<"Contract", 'Float'>
    readonly leaveDays: FieldRef<"Contract", 'Int'>
    readonly leaveMoney: FieldRef<"Contract", 'Float'>
    readonly contractType: FieldRef<"Contract", 'String'>
    readonly probationDays: FieldRef<"Contract", 'Int'>
    readonly basicSalary: FieldRef<"Contract", 'Float'>
    readonly housingAllow: FieldRef<"Contract", 'Float'>
    readonly transportAllow: FieldRef<"Contract", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    daysCount: number | null
    paidAmount: number | null
    approvedBy: number | null
    sickPayRate: number | null
  }

  export type LeaveSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    daysCount: number | null
    paidAmount: number | null
    approvedBy: number | null
    sickPayRate: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    daysCount: number | null
    paid: boolean | null
    paidAmount: number | null
    status: string | null
    requestDate: Date | null
    approvedBy: number | null
    approvedAt: Date | null
    rejectedReason: string | null
    sickPayRate: number | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    daysCount: number | null
    paid: boolean | null
    paidAmount: number | null
    status: string | null
    requestDate: Date | null
    approvedBy: number | null
    approvedAt: Date | null
    rejectedReason: string | null
    sickPayRate: number | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    startDate: number
    endDate: number
    daysCount: number
    paid: number
    paidAmount: number
    status: number
    requestDate: number
    approvedBy: number
    approvedAt: number
    rejectedReason: number
    sickPayRate: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    id?: true
    employeeId?: true
    daysCount?: true
    paidAmount?: true
    approvedBy?: true
    sickPayRate?: true
  }

  export type LeaveSumAggregateInputType = {
    id?: true
    employeeId?: true
    daysCount?: true
    paidAmount?: true
    approvedBy?: true
    sickPayRate?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    daysCount?: true
    paid?: true
    paidAmount?: true
    status?: true
    requestDate?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    sickPayRate?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    daysCount?: true
    paid?: true
    paidAmount?: true
    status?: true
    requestDate?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    sickPayRate?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    daysCount?: true
    paid?: true
    paidAmount?: true
    status?: true
    requestDate?: true
    approvedBy?: true
    approvedAt?: true
    rejectedReason?: true
    sickPayRate?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: number
    employeeId: number
    leaveType: string
    startDate: Date
    endDate: Date
    daysCount: number
    paid: boolean
    paidAmount: number | null
    status: string
    requestDate: Date
    approvedBy: number | null
    approvedAt: Date | null
    rejectedReason: string | null
    sickPayRate: number | null
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    daysCount?: boolean
    paid?: boolean
    paidAmount?: boolean
    status?: boolean
    requestDate?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    sickPayRate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    daysCount?: boolean
    paid?: boolean
    paidAmount?: boolean
    status?: boolean
    requestDate?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    sickPayRate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    daysCount?: boolean
    paid?: boolean
    paidAmount?: boolean
    status?: boolean
    requestDate?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedReason?: boolean
    sickPayRate?: boolean
  }

  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      leaveType: string
      startDate: Date
      endDate: Date
      daysCount: number
      paid: boolean
      paidAmount: number | null
      status: string
      requestDate: Date
      approvedBy: number | null
      approvedAt: Date | null
      rejectedReason: string | null
      sickPayRate: number | null
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaves and returns the data saved in the database.
     * @param {LeaveCreateManyAndReturnArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */ 
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'Int'>
    readonly employeeId: FieldRef<"Leave", 'Int'>
    readonly leaveType: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly daysCount: FieldRef<"Leave", 'Int'>
    readonly paid: FieldRef<"Leave", 'Boolean'>
    readonly paidAmount: FieldRef<"Leave", 'Float'>
    readonly status: FieldRef<"Leave", 'String'>
    readonly requestDate: FieldRef<"Leave", 'DateTime'>
    readonly approvedBy: FieldRef<"Leave", 'Int'>
    readonly approvedAt: FieldRef<"Leave", 'DateTime'>
    readonly rejectedReason: FieldRef<"Leave", 'String'>
    readonly sickPayRate: FieldRef<"Leave", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
  }

  /**
   * Leave createManyAndReturn
   */
  export type LeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model TravelTicket
   */

  export type AggregateTravelTicket = {
    _count: TravelTicketCountAggregateOutputType | null
    _avg: TravelTicketAvgAggregateOutputType | null
    _sum: TravelTicketSumAggregateOutputType | null
    _min: TravelTicketMinAggregateOutputType | null
    _max: TravelTicketMaxAggregateOutputType | null
  }

  export type TravelTicketAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    year: number | null
  }

  export type TravelTicketSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    year: number | null
  }

  export type TravelTicketMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    year: number | null
    issued: boolean | null
    issueDate: Date | null
  }

  export type TravelTicketMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    year: number | null
    issued: boolean | null
    issueDate: Date | null
  }

  export type TravelTicketCountAggregateOutputType = {
    id: number
    employeeId: number
    year: number
    issued: number
    issueDate: number
    _all: number
  }


  export type TravelTicketAvgAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
  }

  export type TravelTicketSumAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
  }

  export type TravelTicketMinAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
    issued?: true
    issueDate?: true
  }

  export type TravelTicketMaxAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
    issued?: true
    issueDate?: true
  }

  export type TravelTicketCountAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
    issued?: true
    issueDate?: true
    _all?: true
  }

  export type TravelTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelTicket to aggregate.
     */
    where?: TravelTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelTickets to fetch.
     */
    orderBy?: TravelTicketOrderByWithRelationInput | TravelTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TravelTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TravelTickets
    **/
    _count?: true | TravelTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TravelTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TravelTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TravelTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TravelTicketMaxAggregateInputType
  }

  export type GetTravelTicketAggregateType<T extends TravelTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTravelTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTravelTicket[P]>
      : GetScalarType<T[P], AggregateTravelTicket[P]>
  }




  export type TravelTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TravelTicketWhereInput
    orderBy?: TravelTicketOrderByWithAggregationInput | TravelTicketOrderByWithAggregationInput[]
    by: TravelTicketScalarFieldEnum[] | TravelTicketScalarFieldEnum
    having?: TravelTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TravelTicketCountAggregateInputType | true
    _avg?: TravelTicketAvgAggregateInputType
    _sum?: TravelTicketSumAggregateInputType
    _min?: TravelTicketMinAggregateInputType
    _max?: TravelTicketMaxAggregateInputType
  }

  export type TravelTicketGroupByOutputType = {
    id: number
    employeeId: number
    year: number
    issued: boolean
    issueDate: Date | null
    _count: TravelTicketCountAggregateOutputType | null
    _avg: TravelTicketAvgAggregateOutputType | null
    _sum: TravelTicketSumAggregateOutputType | null
    _min: TravelTicketMinAggregateOutputType | null
    _max: TravelTicketMaxAggregateOutputType | null
  }

  type GetTravelTicketGroupByPayload<T extends TravelTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TravelTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TravelTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TravelTicketGroupByOutputType[P]>
            : GetScalarType<T[P], TravelTicketGroupByOutputType[P]>
        }
      >
    >


  export type TravelTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    year?: boolean
    issued?: boolean
    issueDate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["travelTicket"]>

  export type TravelTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    year?: boolean
    issued?: boolean
    issueDate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["travelTicket"]>

  export type TravelTicketSelectScalar = {
    id?: boolean
    employeeId?: boolean
    year?: boolean
    issued?: boolean
    issueDate?: boolean
  }

  export type TravelTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type TravelTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $TravelTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TravelTicket"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      year: number
      issued: boolean
      issueDate: Date | null
    }, ExtArgs["result"]["travelTicket"]>
    composites: {}
  }

  type TravelTicketGetPayload<S extends boolean | null | undefined | TravelTicketDefaultArgs> = $Result.GetResult<Prisma.$TravelTicketPayload, S>

  type TravelTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TravelTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TravelTicketCountAggregateInputType | true
    }

  export interface TravelTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TravelTicket'], meta: { name: 'TravelTicket' } }
    /**
     * Find zero or one TravelTicket that matches the filter.
     * @param {TravelTicketFindUniqueArgs} args - Arguments to find a TravelTicket
     * @example
     * // Get one TravelTicket
     * const travelTicket = await prisma.travelTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TravelTicketFindUniqueArgs>(args: SelectSubset<T, TravelTicketFindUniqueArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TravelTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TravelTicketFindUniqueOrThrowArgs} args - Arguments to find a TravelTicket
     * @example
     * // Get one TravelTicket
     * const travelTicket = await prisma.travelTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TravelTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TravelTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TravelTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketFindFirstArgs} args - Arguments to find a TravelTicket
     * @example
     * // Get one TravelTicket
     * const travelTicket = await prisma.travelTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TravelTicketFindFirstArgs>(args?: SelectSubset<T, TravelTicketFindFirstArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TravelTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketFindFirstOrThrowArgs} args - Arguments to find a TravelTicket
     * @example
     * // Get one TravelTicket
     * const travelTicket = await prisma.travelTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TravelTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TravelTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TravelTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TravelTickets
     * const travelTickets = await prisma.travelTicket.findMany()
     * 
     * // Get first 10 TravelTickets
     * const travelTickets = await prisma.travelTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const travelTicketWithIdOnly = await prisma.travelTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TravelTicketFindManyArgs>(args?: SelectSubset<T, TravelTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TravelTicket.
     * @param {TravelTicketCreateArgs} args - Arguments to create a TravelTicket.
     * @example
     * // Create one TravelTicket
     * const TravelTicket = await prisma.travelTicket.create({
     *   data: {
     *     // ... data to create a TravelTicket
     *   }
     * })
     * 
     */
    create<T extends TravelTicketCreateArgs>(args: SelectSubset<T, TravelTicketCreateArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TravelTickets.
     * @param {TravelTicketCreateManyArgs} args - Arguments to create many TravelTickets.
     * @example
     * // Create many TravelTickets
     * const travelTicket = await prisma.travelTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TravelTicketCreateManyArgs>(args?: SelectSubset<T, TravelTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TravelTickets and returns the data saved in the database.
     * @param {TravelTicketCreateManyAndReturnArgs} args - Arguments to create many TravelTickets.
     * @example
     * // Create many TravelTickets
     * const travelTicket = await prisma.travelTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TravelTickets and only return the `id`
     * const travelTicketWithIdOnly = await prisma.travelTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TravelTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TravelTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TravelTicket.
     * @param {TravelTicketDeleteArgs} args - Arguments to delete one TravelTicket.
     * @example
     * // Delete one TravelTicket
     * const TravelTicket = await prisma.travelTicket.delete({
     *   where: {
     *     // ... filter to delete one TravelTicket
     *   }
     * })
     * 
     */
    delete<T extends TravelTicketDeleteArgs>(args: SelectSubset<T, TravelTicketDeleteArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TravelTicket.
     * @param {TravelTicketUpdateArgs} args - Arguments to update one TravelTicket.
     * @example
     * // Update one TravelTicket
     * const travelTicket = await prisma.travelTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TravelTicketUpdateArgs>(args: SelectSubset<T, TravelTicketUpdateArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TravelTickets.
     * @param {TravelTicketDeleteManyArgs} args - Arguments to filter TravelTickets to delete.
     * @example
     * // Delete a few TravelTickets
     * const { count } = await prisma.travelTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TravelTicketDeleteManyArgs>(args?: SelectSubset<T, TravelTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TravelTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TravelTickets
     * const travelTicket = await prisma.travelTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TravelTicketUpdateManyArgs>(args: SelectSubset<T, TravelTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TravelTicket.
     * @param {TravelTicketUpsertArgs} args - Arguments to update or create a TravelTicket.
     * @example
     * // Update or create a TravelTicket
     * const travelTicket = await prisma.travelTicket.upsert({
     *   create: {
     *     // ... data to create a TravelTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TravelTicket we want to update
     *   }
     * })
     */
    upsert<T extends TravelTicketUpsertArgs>(args: SelectSubset<T, TravelTicketUpsertArgs<ExtArgs>>): Prisma__TravelTicketClient<$Result.GetResult<Prisma.$TravelTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TravelTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketCountArgs} args - Arguments to filter TravelTickets to count.
     * @example
     * // Count the number of TravelTickets
     * const count = await prisma.travelTicket.count({
     *   where: {
     *     // ... the filter for the TravelTickets we want to count
     *   }
     * })
    **/
    count<T extends TravelTicketCountArgs>(
      args?: Subset<T, TravelTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TravelTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TravelTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TravelTicketAggregateArgs>(args: Subset<T, TravelTicketAggregateArgs>): Prisma.PrismaPromise<GetTravelTicketAggregateType<T>>

    /**
     * Group by TravelTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TravelTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TravelTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TravelTicketGroupByArgs['orderBy'] }
        : { orderBy?: TravelTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TravelTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTravelTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TravelTicket model
   */
  readonly fields: TravelTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TravelTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TravelTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TravelTicket model
   */ 
  interface TravelTicketFieldRefs {
    readonly id: FieldRef<"TravelTicket", 'Int'>
    readonly employeeId: FieldRef<"TravelTicket", 'Int'>
    readonly year: FieldRef<"TravelTicket", 'Int'>
    readonly issued: FieldRef<"TravelTicket", 'Boolean'>
    readonly issueDate: FieldRef<"TravelTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TravelTicket findUnique
   */
  export type TravelTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * Filter, which TravelTicket to fetch.
     */
    where: TravelTicketWhereUniqueInput
  }

  /**
   * TravelTicket findUniqueOrThrow
   */
  export type TravelTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * Filter, which TravelTicket to fetch.
     */
    where: TravelTicketWhereUniqueInput
  }

  /**
   * TravelTicket findFirst
   */
  export type TravelTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * Filter, which TravelTicket to fetch.
     */
    where?: TravelTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelTickets to fetch.
     */
    orderBy?: TravelTicketOrderByWithRelationInput | TravelTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelTickets.
     */
    cursor?: TravelTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelTickets.
     */
    distinct?: TravelTicketScalarFieldEnum | TravelTicketScalarFieldEnum[]
  }

  /**
   * TravelTicket findFirstOrThrow
   */
  export type TravelTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * Filter, which TravelTicket to fetch.
     */
    where?: TravelTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelTickets to fetch.
     */
    orderBy?: TravelTicketOrderByWithRelationInput | TravelTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TravelTickets.
     */
    cursor?: TravelTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TravelTickets.
     */
    distinct?: TravelTicketScalarFieldEnum | TravelTicketScalarFieldEnum[]
  }

  /**
   * TravelTicket findMany
   */
  export type TravelTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * Filter, which TravelTickets to fetch.
     */
    where?: TravelTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TravelTickets to fetch.
     */
    orderBy?: TravelTicketOrderByWithRelationInput | TravelTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TravelTickets.
     */
    cursor?: TravelTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TravelTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TravelTickets.
     */
    skip?: number
    distinct?: TravelTicketScalarFieldEnum | TravelTicketScalarFieldEnum[]
  }

  /**
   * TravelTicket create
   */
  export type TravelTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a TravelTicket.
     */
    data: XOR<TravelTicketCreateInput, TravelTicketUncheckedCreateInput>
  }

  /**
   * TravelTicket createMany
   */
  export type TravelTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TravelTickets.
     */
    data: TravelTicketCreateManyInput | TravelTicketCreateManyInput[]
  }

  /**
   * TravelTicket createManyAndReturn
   */
  export type TravelTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TravelTickets.
     */
    data: TravelTicketCreateManyInput | TravelTicketCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TravelTicket update
   */
  export type TravelTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a TravelTicket.
     */
    data: XOR<TravelTicketUpdateInput, TravelTicketUncheckedUpdateInput>
    /**
     * Choose, which TravelTicket to update.
     */
    where: TravelTicketWhereUniqueInput
  }

  /**
   * TravelTicket updateMany
   */
  export type TravelTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TravelTickets.
     */
    data: XOR<TravelTicketUpdateManyMutationInput, TravelTicketUncheckedUpdateManyInput>
    /**
     * Filter which TravelTickets to update
     */
    where?: TravelTicketWhereInput
  }

  /**
   * TravelTicket upsert
   */
  export type TravelTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the TravelTicket to update in case it exists.
     */
    where: TravelTicketWhereUniqueInput
    /**
     * In case the TravelTicket found by the `where` argument doesn't exist, create a new TravelTicket with this data.
     */
    create: XOR<TravelTicketCreateInput, TravelTicketUncheckedCreateInput>
    /**
     * In case the TravelTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TravelTicketUpdateInput, TravelTicketUncheckedUpdateInput>
  }

  /**
   * TravelTicket delete
   */
  export type TravelTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
    /**
     * Filter which TravelTicket to delete.
     */
    where: TravelTicketWhereUniqueInput
  }

  /**
   * TravelTicket deleteMany
   */
  export type TravelTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TravelTickets to delete
     */
    where?: TravelTicketWhereInput
  }

  /**
   * TravelTicket without action
   */
  export type TravelTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TravelTicket
     */
    select?: TravelTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TravelTicketInclude<ExtArgs> | null
  }


  /**
   * Model Advance
   */

  export type AggregateAdvance = {
    _count: AdvanceCountAggregateOutputType | null
    _avg: AdvanceAvgAggregateOutputType | null
    _sum: AdvanceSumAggregateOutputType | null
    _min: AdvanceMinAggregateOutputType | null
    _max: AdvanceMaxAggregateOutputType | null
  }

  export type AdvanceAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: number | null
  }

  export type AdvanceSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: number | null
  }

  export type AdvanceMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: number | null
    date: Date | null
    status: string | null
  }

  export type AdvanceMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: number | null
    date: Date | null
    status: string | null
  }

  export type AdvanceCountAggregateOutputType = {
    id: number
    employeeId: number
    amount: number
    date: number
    status: number
    _all: number
  }


  export type AdvanceAvgAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
  }

  export type AdvanceSumAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
  }

  export type AdvanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    date?: true
    status?: true
  }

  export type AdvanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    date?: true
    status?: true
  }

  export type AdvanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    date?: true
    status?: true
    _all?: true
  }

  export type AdvanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advance to aggregate.
     */
    where?: AdvanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advances to fetch.
     */
    orderBy?: AdvanceOrderByWithRelationInput | AdvanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advances
    **/
    _count?: true | AdvanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvanceMaxAggregateInputType
  }

  export type GetAdvanceAggregateType<T extends AdvanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvance[P]>
      : GetScalarType<T[P], AggregateAdvance[P]>
  }




  export type AdvanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvanceWhereInput
    orderBy?: AdvanceOrderByWithAggregationInput | AdvanceOrderByWithAggregationInput[]
    by: AdvanceScalarFieldEnum[] | AdvanceScalarFieldEnum
    having?: AdvanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvanceCountAggregateInputType | true
    _avg?: AdvanceAvgAggregateInputType
    _sum?: AdvanceSumAggregateInputType
    _min?: AdvanceMinAggregateInputType
    _max?: AdvanceMaxAggregateInputType
  }

  export type AdvanceGroupByOutputType = {
    id: number
    employeeId: number
    amount: number
    date: Date
    status: string
    _count: AdvanceCountAggregateOutputType | null
    _avg: AdvanceAvgAggregateOutputType | null
    _sum: AdvanceSumAggregateOutputType | null
    _min: AdvanceMinAggregateOutputType | null
    _max: AdvanceMaxAggregateOutputType | null
  }

  type GetAdvanceGroupByPayload<T extends AdvanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvanceGroupByOutputType[P]>
            : GetScalarType<T[P], AdvanceGroupByOutputType[P]>
        }
      >
    >


  export type AdvanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    date?: boolean
    status?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advance"]>

  export type AdvanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    date?: boolean
    status?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advance"]>

  export type AdvanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    date?: boolean
    status?: boolean
  }

  export type AdvanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AdvanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AdvancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advance"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      amount: number
      date: Date
      status: string
    }, ExtArgs["result"]["advance"]>
    composites: {}
  }

  type AdvanceGetPayload<S extends boolean | null | undefined | AdvanceDefaultArgs> = $Result.GetResult<Prisma.$AdvancePayload, S>

  type AdvanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvanceCountAggregateInputType | true
    }

  export interface AdvanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advance'], meta: { name: 'Advance' } }
    /**
     * Find zero or one Advance that matches the filter.
     * @param {AdvanceFindUniqueArgs} args - Arguments to find a Advance
     * @example
     * // Get one Advance
     * const advance = await prisma.advance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvanceFindUniqueArgs>(args: SelectSubset<T, AdvanceFindUniqueArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Advance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvanceFindUniqueOrThrowArgs} args - Arguments to find a Advance
     * @example
     * // Get one Advance
     * const advance = await prisma.advance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Advance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceFindFirstArgs} args - Arguments to find a Advance
     * @example
     * // Get one Advance
     * const advance = await prisma.advance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvanceFindFirstArgs>(args?: SelectSubset<T, AdvanceFindFirstArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Advance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceFindFirstOrThrowArgs} args - Arguments to find a Advance
     * @example
     * // Get one Advance
     * const advance = await prisma.advance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Advances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advances
     * const advances = await prisma.advance.findMany()
     * 
     * // Get first 10 Advances
     * const advances = await prisma.advance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advanceWithIdOnly = await prisma.advance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvanceFindManyArgs>(args?: SelectSubset<T, AdvanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Advance.
     * @param {AdvanceCreateArgs} args - Arguments to create a Advance.
     * @example
     * // Create one Advance
     * const Advance = await prisma.advance.create({
     *   data: {
     *     // ... data to create a Advance
     *   }
     * })
     * 
     */
    create<T extends AdvanceCreateArgs>(args: SelectSubset<T, AdvanceCreateArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Advances.
     * @param {AdvanceCreateManyArgs} args - Arguments to create many Advances.
     * @example
     * // Create many Advances
     * const advance = await prisma.advance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvanceCreateManyArgs>(args?: SelectSubset<T, AdvanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Advances and returns the data saved in the database.
     * @param {AdvanceCreateManyAndReturnArgs} args - Arguments to create many Advances.
     * @example
     * // Create many Advances
     * const advance = await prisma.advance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Advances and only return the `id`
     * const advanceWithIdOnly = await prisma.advance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Advance.
     * @param {AdvanceDeleteArgs} args - Arguments to delete one Advance.
     * @example
     * // Delete one Advance
     * const Advance = await prisma.advance.delete({
     *   where: {
     *     // ... filter to delete one Advance
     *   }
     * })
     * 
     */
    delete<T extends AdvanceDeleteArgs>(args: SelectSubset<T, AdvanceDeleteArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Advance.
     * @param {AdvanceUpdateArgs} args - Arguments to update one Advance.
     * @example
     * // Update one Advance
     * const advance = await prisma.advance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvanceUpdateArgs>(args: SelectSubset<T, AdvanceUpdateArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Advances.
     * @param {AdvanceDeleteManyArgs} args - Arguments to filter Advances to delete.
     * @example
     * // Delete a few Advances
     * const { count } = await prisma.advance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvanceDeleteManyArgs>(args?: SelectSubset<T, AdvanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advances
     * const advance = await prisma.advance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvanceUpdateManyArgs>(args: SelectSubset<T, AdvanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advance.
     * @param {AdvanceUpsertArgs} args - Arguments to update or create a Advance.
     * @example
     * // Update or create a Advance
     * const advance = await prisma.advance.upsert({
     *   create: {
     *     // ... data to create a Advance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advance we want to update
     *   }
     * })
     */
    upsert<T extends AdvanceUpsertArgs>(args: SelectSubset<T, AdvanceUpsertArgs<ExtArgs>>): Prisma__AdvanceClient<$Result.GetResult<Prisma.$AdvancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Advances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceCountArgs} args - Arguments to filter Advances to count.
     * @example
     * // Count the number of Advances
     * const count = await prisma.advance.count({
     *   where: {
     *     // ... the filter for the Advances we want to count
     *   }
     * })
    **/
    count<T extends AdvanceCountArgs>(
      args?: Subset<T, AdvanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvanceAggregateArgs>(args: Subset<T, AdvanceAggregateArgs>): Prisma.PrismaPromise<GetAdvanceAggregateType<T>>

    /**
     * Group by Advance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvanceGroupByArgs['orderBy'] }
        : { orderBy?: AdvanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advance model
   */
  readonly fields: AdvanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Advance model
   */ 
  interface AdvanceFieldRefs {
    readonly id: FieldRef<"Advance", 'Int'>
    readonly employeeId: FieldRef<"Advance", 'Int'>
    readonly amount: FieldRef<"Advance", 'Float'>
    readonly date: FieldRef<"Advance", 'DateTime'>
    readonly status: FieldRef<"Advance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Advance findUnique
   */
  export type AdvanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * Filter, which Advance to fetch.
     */
    where: AdvanceWhereUniqueInput
  }

  /**
   * Advance findUniqueOrThrow
   */
  export type AdvanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * Filter, which Advance to fetch.
     */
    where: AdvanceWhereUniqueInput
  }

  /**
   * Advance findFirst
   */
  export type AdvanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * Filter, which Advance to fetch.
     */
    where?: AdvanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advances to fetch.
     */
    orderBy?: AdvanceOrderByWithRelationInput | AdvanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advances.
     */
    cursor?: AdvanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advances.
     */
    distinct?: AdvanceScalarFieldEnum | AdvanceScalarFieldEnum[]
  }

  /**
   * Advance findFirstOrThrow
   */
  export type AdvanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * Filter, which Advance to fetch.
     */
    where?: AdvanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advances to fetch.
     */
    orderBy?: AdvanceOrderByWithRelationInput | AdvanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advances.
     */
    cursor?: AdvanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advances.
     */
    distinct?: AdvanceScalarFieldEnum | AdvanceScalarFieldEnum[]
  }

  /**
   * Advance findMany
   */
  export type AdvanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * Filter, which Advances to fetch.
     */
    where?: AdvanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advances to fetch.
     */
    orderBy?: AdvanceOrderByWithRelationInput | AdvanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advances.
     */
    cursor?: AdvanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advances.
     */
    skip?: number
    distinct?: AdvanceScalarFieldEnum | AdvanceScalarFieldEnum[]
  }

  /**
   * Advance create
   */
  export type AdvanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Advance.
     */
    data: XOR<AdvanceCreateInput, AdvanceUncheckedCreateInput>
  }

  /**
   * Advance createMany
   */
  export type AdvanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advances.
     */
    data: AdvanceCreateManyInput | AdvanceCreateManyInput[]
  }

  /**
   * Advance createManyAndReturn
   */
  export type AdvanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Advances.
     */
    data: AdvanceCreateManyInput | AdvanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Advance update
   */
  export type AdvanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Advance.
     */
    data: XOR<AdvanceUpdateInput, AdvanceUncheckedUpdateInput>
    /**
     * Choose, which Advance to update.
     */
    where: AdvanceWhereUniqueInput
  }

  /**
   * Advance updateMany
   */
  export type AdvanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advances.
     */
    data: XOR<AdvanceUpdateManyMutationInput, AdvanceUncheckedUpdateManyInput>
    /**
     * Filter which Advances to update
     */
    where?: AdvanceWhereInput
  }

  /**
   * Advance upsert
   */
  export type AdvanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Advance to update in case it exists.
     */
    where: AdvanceWhereUniqueInput
    /**
     * In case the Advance found by the `where` argument doesn't exist, create a new Advance with this data.
     */
    create: XOR<AdvanceCreateInput, AdvanceUncheckedCreateInput>
    /**
     * In case the Advance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvanceUpdateInput, AdvanceUncheckedUpdateInput>
  }

  /**
   * Advance delete
   */
  export type AdvanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
    /**
     * Filter which Advance to delete.
     */
    where: AdvanceWhereUniqueInput
  }

  /**
   * Advance deleteMany
   */
  export type AdvanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advances to delete
     */
    where?: AdvanceWhereInput
  }

  /**
   * Advance without action
   */
  export type AdvanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advance
     */
    select?: AdvanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvanceInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type AssetSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    assetType: string | null
    description: string | null
    assignedDate: Date | null
    returned: boolean | null
    returnDate: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    assetType: string | null
    description: string | null
    assignedDate: Date | null
    returned: boolean | null
    returnDate: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    employeeId: number
    assetType: number
    description: number
    assignedDate: number
    returned: number
    returnDate: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type AssetSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    employeeId?: true
    assetType?: true
    description?: true
    assignedDate?: true
    returned?: true
    returnDate?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    employeeId?: true
    assetType?: true
    description?: true
    assignedDate?: true
    returned?: true
    returnDate?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    employeeId?: true
    assetType?: true
    description?: true
    assignedDate?: true
    returned?: true
    returnDate?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: number
    employeeId: number
    assetType: string
    description: string | null
    assignedDate: Date
    returned: boolean
    returnDate: Date | null
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assetType?: boolean
    description?: boolean
    assignedDate?: boolean
    returned?: boolean
    returnDate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    assetType?: boolean
    description?: boolean
    assignedDate?: boolean
    returned?: boolean
    returnDate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    employeeId?: boolean
    assetType?: boolean
    description?: boolean
    assignedDate?: boolean
    returned?: boolean
    returnDate?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      assetType: string
      description: string | null
      assignedDate: Date
      returned: boolean
      returnDate: Date | null
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'Int'>
    readonly employeeId: FieldRef<"Asset", 'Int'>
    readonly assetType: FieldRef<"Asset", 'String'>
    readonly description: FieldRef<"Asset", 'String'>
    readonly assignedDate: FieldRef<"Asset", 'DateTime'>
    readonly returned: FieldRef<"Asset", 'Boolean'>
    readonly returnDate: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    checkIn: number
    checkOut: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    checkIn?: true
    checkOut?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    checkIn?: true
    checkOut?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    checkIn?: true
    checkOut?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    checkIn: Date | null
    checkOut: Date | null
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
  }

  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      checkIn: Date | null
      checkOut: Date | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */ 
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'Int'>
    readonly employeeId: FieldRef<"Attendance", 'Int'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly checkIn: FieldRef<"Attendance", 'DateTime'>
    readonly checkOut: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Entitlement
   */

  export type AggregateEntitlement = {
    _count: EntitlementCountAggregateOutputType | null
    _avg: EntitlementAvgAggregateOutputType | null
    _sum: EntitlementSumAggregateOutputType | null
    _min: EntitlementMinAggregateOutputType | null
    _max: EntitlementMaxAggregateOutputType | null
  }

  export type EntitlementAvgAggregateOutputType = {
    id: number | null
    yearsWorked: number | null
    fraction: number | null
    employeeId: number | null
    amount: number | null
  }

  export type EntitlementSumAggregateOutputType = {
    id: number | null
    yearsWorked: number | null
    fraction: number | null
    employeeId: number | null
    amount: number | null
  }

  export type EntitlementMinAggregateOutputType = {
    id: number | null
    yearsWorked: number | null
    fraction: number | null
    terminationType: string | null
    paid: boolean | null
    paidDate: Date | null
    employeeId: number | null
    type: string | null
    amount: number | null
    calculatedAt: Date | null
  }

  export type EntitlementMaxAggregateOutputType = {
    id: number | null
    yearsWorked: number | null
    fraction: number | null
    terminationType: string | null
    paid: boolean | null
    paidDate: Date | null
    employeeId: number | null
    type: string | null
    amount: number | null
    calculatedAt: Date | null
  }

  export type EntitlementCountAggregateOutputType = {
    id: number
    yearsWorked: number
    fraction: number
    terminationType: number
    paid: number
    paidDate: number
    employeeId: number
    type: number
    amount: number
    calculatedAt: number
    _all: number
  }


  export type EntitlementAvgAggregateInputType = {
    id?: true
    yearsWorked?: true
    fraction?: true
    employeeId?: true
    amount?: true
  }

  export type EntitlementSumAggregateInputType = {
    id?: true
    yearsWorked?: true
    fraction?: true
    employeeId?: true
    amount?: true
  }

  export type EntitlementMinAggregateInputType = {
    id?: true
    yearsWorked?: true
    fraction?: true
    terminationType?: true
    paid?: true
    paidDate?: true
    employeeId?: true
    type?: true
    amount?: true
    calculatedAt?: true
  }

  export type EntitlementMaxAggregateInputType = {
    id?: true
    yearsWorked?: true
    fraction?: true
    terminationType?: true
    paid?: true
    paidDate?: true
    employeeId?: true
    type?: true
    amount?: true
    calculatedAt?: true
  }

  export type EntitlementCountAggregateInputType = {
    id?: true
    yearsWorked?: true
    fraction?: true
    terminationType?: true
    paid?: true
    paidDate?: true
    employeeId?: true
    type?: true
    amount?: true
    calculatedAt?: true
    _all?: true
  }

  export type EntitlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entitlement to aggregate.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entitlements
    **/
    _count?: true | EntitlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntitlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntitlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntitlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntitlementMaxAggregateInputType
  }

  export type GetEntitlementAggregateType<T extends EntitlementAggregateArgs> = {
        [P in keyof T & keyof AggregateEntitlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntitlement[P]>
      : GetScalarType<T[P], AggregateEntitlement[P]>
  }




  export type EntitlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntitlementWhereInput
    orderBy?: EntitlementOrderByWithAggregationInput | EntitlementOrderByWithAggregationInput[]
    by: EntitlementScalarFieldEnum[] | EntitlementScalarFieldEnum
    having?: EntitlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntitlementCountAggregateInputType | true
    _avg?: EntitlementAvgAggregateInputType
    _sum?: EntitlementSumAggregateInputType
    _min?: EntitlementMinAggregateInputType
    _max?: EntitlementMaxAggregateInputType
  }

  export type EntitlementGroupByOutputType = {
    id: number
    yearsWorked: number | null
    fraction: number | null
    terminationType: string | null
    paid: boolean
    paidDate: Date | null
    employeeId: number
    type: string
    amount: number
    calculatedAt: Date
    _count: EntitlementCountAggregateOutputType | null
    _avg: EntitlementAvgAggregateOutputType | null
    _sum: EntitlementSumAggregateOutputType | null
    _min: EntitlementMinAggregateOutputType | null
    _max: EntitlementMaxAggregateOutputType | null
  }

  type GetEntitlementGroupByPayload<T extends EntitlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntitlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntitlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntitlementGroupByOutputType[P]>
            : GetScalarType<T[P], EntitlementGroupByOutputType[P]>
        }
      >
    >


  export type EntitlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearsWorked?: boolean
    fraction?: boolean
    terminationType?: boolean
    paid?: boolean
    paidDate?: boolean
    employeeId?: boolean
    type?: boolean
    amount?: boolean
    calculatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entitlement"]>

  export type EntitlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    yearsWorked?: boolean
    fraction?: boolean
    terminationType?: boolean
    paid?: boolean
    paidDate?: boolean
    employeeId?: boolean
    type?: boolean
    amount?: boolean
    calculatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entitlement"]>

  export type EntitlementSelectScalar = {
    id?: boolean
    yearsWorked?: boolean
    fraction?: boolean
    terminationType?: boolean
    paid?: boolean
    paidDate?: boolean
    employeeId?: boolean
    type?: boolean
    amount?: boolean
    calculatedAt?: boolean
  }

  export type EntitlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EntitlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EntitlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entitlement"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      yearsWorked: number | null
      fraction: number | null
      terminationType: string | null
      paid: boolean
      paidDate: Date | null
      employeeId: number
      type: string
      amount: number
      calculatedAt: Date
    }, ExtArgs["result"]["entitlement"]>
    composites: {}
  }

  type EntitlementGetPayload<S extends boolean | null | undefined | EntitlementDefaultArgs> = $Result.GetResult<Prisma.$EntitlementPayload, S>

  type EntitlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntitlementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntitlementCountAggregateInputType | true
    }

  export interface EntitlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entitlement'], meta: { name: 'Entitlement' } }
    /**
     * Find zero or one Entitlement that matches the filter.
     * @param {EntitlementFindUniqueArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntitlementFindUniqueArgs>(args: SelectSubset<T, EntitlementFindUniqueArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Entitlement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntitlementFindUniqueOrThrowArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntitlementFindUniqueOrThrowArgs>(args: SelectSubset<T, EntitlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Entitlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindFirstArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntitlementFindFirstArgs>(args?: SelectSubset<T, EntitlementFindFirstArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Entitlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindFirstOrThrowArgs} args - Arguments to find a Entitlement
     * @example
     * // Get one Entitlement
     * const entitlement = await prisma.entitlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntitlementFindFirstOrThrowArgs>(args?: SelectSubset<T, EntitlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Entitlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entitlements
     * const entitlements = await prisma.entitlement.findMany()
     * 
     * // Get first 10 Entitlements
     * const entitlements = await prisma.entitlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entitlementWithIdOnly = await prisma.entitlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntitlementFindManyArgs>(args?: SelectSubset<T, EntitlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Entitlement.
     * @param {EntitlementCreateArgs} args - Arguments to create a Entitlement.
     * @example
     * // Create one Entitlement
     * const Entitlement = await prisma.entitlement.create({
     *   data: {
     *     // ... data to create a Entitlement
     *   }
     * })
     * 
     */
    create<T extends EntitlementCreateArgs>(args: SelectSubset<T, EntitlementCreateArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Entitlements.
     * @param {EntitlementCreateManyArgs} args - Arguments to create many Entitlements.
     * @example
     * // Create many Entitlements
     * const entitlement = await prisma.entitlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntitlementCreateManyArgs>(args?: SelectSubset<T, EntitlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entitlements and returns the data saved in the database.
     * @param {EntitlementCreateManyAndReturnArgs} args - Arguments to create many Entitlements.
     * @example
     * // Create many Entitlements
     * const entitlement = await prisma.entitlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entitlements and only return the `id`
     * const entitlementWithIdOnly = await prisma.entitlement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntitlementCreateManyAndReturnArgs>(args?: SelectSubset<T, EntitlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Entitlement.
     * @param {EntitlementDeleteArgs} args - Arguments to delete one Entitlement.
     * @example
     * // Delete one Entitlement
     * const Entitlement = await prisma.entitlement.delete({
     *   where: {
     *     // ... filter to delete one Entitlement
     *   }
     * })
     * 
     */
    delete<T extends EntitlementDeleteArgs>(args: SelectSubset<T, EntitlementDeleteArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Entitlement.
     * @param {EntitlementUpdateArgs} args - Arguments to update one Entitlement.
     * @example
     * // Update one Entitlement
     * const entitlement = await prisma.entitlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntitlementUpdateArgs>(args: SelectSubset<T, EntitlementUpdateArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Entitlements.
     * @param {EntitlementDeleteManyArgs} args - Arguments to filter Entitlements to delete.
     * @example
     * // Delete a few Entitlements
     * const { count } = await prisma.entitlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntitlementDeleteManyArgs>(args?: SelectSubset<T, EntitlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entitlements
     * const entitlement = await prisma.entitlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntitlementUpdateManyArgs>(args: SelectSubset<T, EntitlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entitlement.
     * @param {EntitlementUpsertArgs} args - Arguments to update or create a Entitlement.
     * @example
     * // Update or create a Entitlement
     * const entitlement = await prisma.entitlement.upsert({
     *   create: {
     *     // ... data to create a Entitlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entitlement we want to update
     *   }
     * })
     */
    upsert<T extends EntitlementUpsertArgs>(args: SelectSubset<T, EntitlementUpsertArgs<ExtArgs>>): Prisma__EntitlementClient<$Result.GetResult<Prisma.$EntitlementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Entitlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementCountArgs} args - Arguments to filter Entitlements to count.
     * @example
     * // Count the number of Entitlements
     * const count = await prisma.entitlement.count({
     *   where: {
     *     // ... the filter for the Entitlements we want to count
     *   }
     * })
    **/
    count<T extends EntitlementCountArgs>(
      args?: Subset<T, EntitlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntitlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entitlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntitlementAggregateArgs>(args: Subset<T, EntitlementAggregateArgs>): Prisma.PrismaPromise<GetEntitlementAggregateType<T>>

    /**
     * Group by Entitlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntitlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntitlementGroupByArgs['orderBy'] }
        : { orderBy?: EntitlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntitlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntitlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entitlement model
   */
  readonly fields: EntitlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entitlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntitlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entitlement model
   */ 
  interface EntitlementFieldRefs {
    readonly id: FieldRef<"Entitlement", 'Int'>
    readonly yearsWorked: FieldRef<"Entitlement", 'Float'>
    readonly fraction: FieldRef<"Entitlement", 'Float'>
    readonly terminationType: FieldRef<"Entitlement", 'String'>
    readonly paid: FieldRef<"Entitlement", 'Boolean'>
    readonly paidDate: FieldRef<"Entitlement", 'DateTime'>
    readonly employeeId: FieldRef<"Entitlement", 'Int'>
    readonly type: FieldRef<"Entitlement", 'String'>
    readonly amount: FieldRef<"Entitlement", 'Float'>
    readonly calculatedAt: FieldRef<"Entitlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entitlement findUnique
   */
  export type EntitlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement findUniqueOrThrow
   */
  export type EntitlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement findFirst
   */
  export type EntitlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entitlements.
     */
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement findFirstOrThrow
   */
  export type EntitlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlement to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entitlements.
     */
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement findMany
   */
  export type EntitlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter, which Entitlements to fetch.
     */
    where?: EntitlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entitlements to fetch.
     */
    orderBy?: EntitlementOrderByWithRelationInput | EntitlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entitlements.
     */
    cursor?: EntitlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entitlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entitlements.
     */
    skip?: number
    distinct?: EntitlementScalarFieldEnum | EntitlementScalarFieldEnum[]
  }

  /**
   * Entitlement create
   */
  export type EntitlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The data needed to create a Entitlement.
     */
    data: XOR<EntitlementCreateInput, EntitlementUncheckedCreateInput>
  }

  /**
   * Entitlement createMany
   */
  export type EntitlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entitlements.
     */
    data: EntitlementCreateManyInput | EntitlementCreateManyInput[]
  }

  /**
   * Entitlement createManyAndReturn
   */
  export type EntitlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Entitlements.
     */
    data: EntitlementCreateManyInput | EntitlementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Entitlement update
   */
  export type EntitlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The data needed to update a Entitlement.
     */
    data: XOR<EntitlementUpdateInput, EntitlementUncheckedUpdateInput>
    /**
     * Choose, which Entitlement to update.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement updateMany
   */
  export type EntitlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entitlements.
     */
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyInput>
    /**
     * Filter which Entitlements to update
     */
    where?: EntitlementWhereInput
  }

  /**
   * Entitlement upsert
   */
  export type EntitlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * The filter to search for the Entitlement to update in case it exists.
     */
    where: EntitlementWhereUniqueInput
    /**
     * In case the Entitlement found by the `where` argument doesn't exist, create a new Entitlement with this data.
     */
    create: XOR<EntitlementCreateInput, EntitlementUncheckedCreateInput>
    /**
     * In case the Entitlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntitlementUpdateInput, EntitlementUncheckedUpdateInput>
  }

  /**
   * Entitlement delete
   */
  export type EntitlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
    /**
     * Filter which Entitlement to delete.
     */
    where: EntitlementWhereUniqueInput
  }

  /**
   * Entitlement deleteMany
   */
  export type EntitlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entitlements to delete
     */
    where?: EntitlementWhereInput
  }

  /**
   * Entitlement without action
   */
  export type EntitlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entitlement
     */
    select?: EntitlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntitlementInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type DocumentSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    docType: string | null
    expiryDate: Date | null
    number: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    docType: string | null
    expiryDate: Date | null
    number: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    employeeId: number
    docType: number
    expiryDate: number
    number: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type DocumentSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    employeeId?: true
    docType?: true
    expiryDate?: true
    number?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    docType?: true
    expiryDate?: true
    number?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    employeeId?: true
    docType?: true
    expiryDate?: true
    number?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: number
    employeeId: number
    docType: string
    expiryDate: Date
    number: string | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    docType?: boolean
    expiryDate?: boolean
    number?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    docType?: boolean
    expiryDate?: boolean
    number?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    docType?: boolean
    expiryDate?: boolean
    number?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      docType: string
      expiryDate: Date
      number: string | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'Int'>
    readonly employeeId: FieldRef<"Document", 'Int'>
    readonly docType: FieldRef<"Document", 'String'>
    readonly expiryDate: FieldRef<"Document", 'DateTime'>
    readonly number: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    entityId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entityType: string | null
    entityId: number | null
    before: string | null
    after: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    action: string | null
    entityType: string | null
    entityId: number | null
    before: string | null
    after: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    before: number
    after: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    userId?: true
    entityId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    before?: true
    after?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    before?: true
    after?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    before?: true
    after?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userId: number
    action: string
    entityType: string
    entityId: number
    before: string | null
    after: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    before?: boolean
    after?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      action: string
      entityType: string
      entityId: number
      before: string | null
      after: string | null
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly before: FieldRef<"AuditLog", 'String'>
    readonly after: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model PayrollRun
   */

  export type AggregatePayrollRun = {
    _count: PayrollRunCountAggregateOutputType | null
    _avg: PayrollRunAvgAggregateOutputType | null
    _sum: PayrollRunSumAggregateOutputType | null
    _min: PayrollRunMinAggregateOutputType | null
    _max: PayrollRunMaxAggregateOutputType | null
  }

  export type PayrollRunAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
    approvedBy: number | null
    totalGross: number | null
    totalNet: number | null
    totalDeductions: number | null
  }

  export type PayrollRunSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
    approvedBy: number | null
    totalGross: number | null
    totalNet: number | null
    totalDeductions: number | null
  }

  export type PayrollRunMinAggregateOutputType = {
    id: number | null
    periodStart: Date | null
    periodEnd: Date | null
    status: string | null
    createdBy: number | null
    createdAt: Date | null
    approvedBy: number | null
    approvedAt: Date | null
    lockedAt: Date | null
    totalGross: number | null
    totalNet: number | null
    totalDeductions: number | null
  }

  export type PayrollRunMaxAggregateOutputType = {
    id: number | null
    periodStart: Date | null
    periodEnd: Date | null
    status: string | null
    createdBy: number | null
    createdAt: Date | null
    approvedBy: number | null
    approvedAt: Date | null
    lockedAt: Date | null
    totalGross: number | null
    totalNet: number | null
    totalDeductions: number | null
  }

  export type PayrollRunCountAggregateOutputType = {
    id: number
    periodStart: number
    periodEnd: number
    status: number
    createdBy: number
    createdAt: number
    approvedBy: number
    approvedAt: number
    lockedAt: number
    totalGross: number
    totalNet: number
    totalDeductions: number
    _all: number
  }


  export type PayrollRunAvgAggregateInputType = {
    id?: true
    createdBy?: true
    approvedBy?: true
    totalGross?: true
    totalNet?: true
    totalDeductions?: true
  }

  export type PayrollRunSumAggregateInputType = {
    id?: true
    createdBy?: true
    approvedBy?: true
    totalGross?: true
    totalNet?: true
    totalDeductions?: true
  }

  export type PayrollRunMinAggregateInputType = {
    id?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedBy?: true
    approvedAt?: true
    lockedAt?: true
    totalGross?: true
    totalNet?: true
    totalDeductions?: true
  }

  export type PayrollRunMaxAggregateInputType = {
    id?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedBy?: true
    approvedAt?: true
    lockedAt?: true
    totalGross?: true
    totalNet?: true
    totalDeductions?: true
  }

  export type PayrollRunCountAggregateInputType = {
    id?: true
    periodStart?: true
    periodEnd?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedBy?: true
    approvedAt?: true
    lockedAt?: true
    totalGross?: true
    totalNet?: true
    totalDeductions?: true
    _all?: true
  }

  export type PayrollRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollRun to aggregate.
     */
    where?: PayrollRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRuns to fetch.
     */
    orderBy?: PayrollRunOrderByWithRelationInput | PayrollRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollRuns
    **/
    _count?: true | PayrollRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollRunMaxAggregateInputType
  }

  export type GetPayrollRunAggregateType<T extends PayrollRunAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollRun[P]>
      : GetScalarType<T[P], AggregatePayrollRun[P]>
  }




  export type PayrollRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollRunWhereInput
    orderBy?: PayrollRunOrderByWithAggregationInput | PayrollRunOrderByWithAggregationInput[]
    by: PayrollRunScalarFieldEnum[] | PayrollRunScalarFieldEnum
    having?: PayrollRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollRunCountAggregateInputType | true
    _avg?: PayrollRunAvgAggregateInputType
    _sum?: PayrollRunSumAggregateInputType
    _min?: PayrollRunMinAggregateInputType
    _max?: PayrollRunMaxAggregateInputType
  }

  export type PayrollRunGroupByOutputType = {
    id: number
    periodStart: Date
    periodEnd: Date
    status: string
    createdBy: number
    createdAt: Date
    approvedBy: number | null
    approvedAt: Date | null
    lockedAt: Date | null
    totalGross: number | null
    totalNet: number | null
    totalDeductions: number | null
    _count: PayrollRunCountAggregateOutputType | null
    _avg: PayrollRunAvgAggregateOutputType | null
    _sum: PayrollRunSumAggregateOutputType | null
    _min: PayrollRunMinAggregateOutputType | null
    _max: PayrollRunMaxAggregateOutputType | null
  }

  type GetPayrollRunGroupByPayload<T extends PayrollRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollRunGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollRunGroupByOutputType[P]>
        }
      >
    >


  export type PayrollRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    totalGross?: boolean
    totalNet?: boolean
    totalDeductions?: boolean
    items?: boolean | PayrollRun$itemsArgs<ExtArgs>
    _count?: boolean | PayrollRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollRun"]>

  export type PayrollRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    totalGross?: boolean
    totalNet?: boolean
    totalDeductions?: boolean
  }, ExtArgs["result"]["payrollRun"]>

  export type PayrollRunSelectScalar = {
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    totalGross?: boolean
    totalNet?: boolean
    totalDeductions?: boolean
  }

  export type PayrollRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PayrollRun$itemsArgs<ExtArgs>
    _count?: boolean | PayrollRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PayrollRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollRun"
    objects: {
      items: Prisma.$PayrollItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      periodStart: Date
      periodEnd: Date
      status: string
      createdBy: number
      createdAt: Date
      approvedBy: number | null
      approvedAt: Date | null
      lockedAt: Date | null
      totalGross: number | null
      totalNet: number | null
      totalDeductions: number | null
    }, ExtArgs["result"]["payrollRun"]>
    composites: {}
  }

  type PayrollRunGetPayload<S extends boolean | null | undefined | PayrollRunDefaultArgs> = $Result.GetResult<Prisma.$PayrollRunPayload, S>

  type PayrollRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayrollRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayrollRunCountAggregateInputType | true
    }

  export interface PayrollRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollRun'], meta: { name: 'PayrollRun' } }
    /**
     * Find zero or one PayrollRun that matches the filter.
     * @param {PayrollRunFindUniqueArgs} args - Arguments to find a PayrollRun
     * @example
     * // Get one PayrollRun
     * const payrollRun = await prisma.payrollRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollRunFindUniqueArgs>(args: SelectSubset<T, PayrollRunFindUniqueArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PayrollRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayrollRunFindUniqueOrThrowArgs} args - Arguments to find a PayrollRun
     * @example
     * // Get one PayrollRun
     * const payrollRun = await prisma.payrollRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollRunFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PayrollRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunFindFirstArgs} args - Arguments to find a PayrollRun
     * @example
     * // Get one PayrollRun
     * const payrollRun = await prisma.payrollRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollRunFindFirstArgs>(args?: SelectSubset<T, PayrollRunFindFirstArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PayrollRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunFindFirstOrThrowArgs} args - Arguments to find a PayrollRun
     * @example
     * // Get one PayrollRun
     * const payrollRun = await prisma.payrollRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollRunFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PayrollRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollRuns
     * const payrollRuns = await prisma.payrollRun.findMany()
     * 
     * // Get first 10 PayrollRuns
     * const payrollRuns = await prisma.payrollRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollRunWithIdOnly = await prisma.payrollRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollRunFindManyArgs>(args?: SelectSubset<T, PayrollRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PayrollRun.
     * @param {PayrollRunCreateArgs} args - Arguments to create a PayrollRun.
     * @example
     * // Create one PayrollRun
     * const PayrollRun = await prisma.payrollRun.create({
     *   data: {
     *     // ... data to create a PayrollRun
     *   }
     * })
     * 
     */
    create<T extends PayrollRunCreateArgs>(args: SelectSubset<T, PayrollRunCreateArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PayrollRuns.
     * @param {PayrollRunCreateManyArgs} args - Arguments to create many PayrollRuns.
     * @example
     * // Create many PayrollRuns
     * const payrollRun = await prisma.payrollRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollRunCreateManyArgs>(args?: SelectSubset<T, PayrollRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollRuns and returns the data saved in the database.
     * @param {PayrollRunCreateManyAndReturnArgs} args - Arguments to create many PayrollRuns.
     * @example
     * // Create many PayrollRuns
     * const payrollRun = await prisma.payrollRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollRuns and only return the `id`
     * const payrollRunWithIdOnly = await prisma.payrollRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollRunCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PayrollRun.
     * @param {PayrollRunDeleteArgs} args - Arguments to delete one PayrollRun.
     * @example
     * // Delete one PayrollRun
     * const PayrollRun = await prisma.payrollRun.delete({
     *   where: {
     *     // ... filter to delete one PayrollRun
     *   }
     * })
     * 
     */
    delete<T extends PayrollRunDeleteArgs>(args: SelectSubset<T, PayrollRunDeleteArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PayrollRun.
     * @param {PayrollRunUpdateArgs} args - Arguments to update one PayrollRun.
     * @example
     * // Update one PayrollRun
     * const payrollRun = await prisma.payrollRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollRunUpdateArgs>(args: SelectSubset<T, PayrollRunUpdateArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PayrollRuns.
     * @param {PayrollRunDeleteManyArgs} args - Arguments to filter PayrollRuns to delete.
     * @example
     * // Delete a few PayrollRuns
     * const { count } = await prisma.payrollRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollRunDeleteManyArgs>(args?: SelectSubset<T, PayrollRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollRuns
     * const payrollRun = await prisma.payrollRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollRunUpdateManyArgs>(args: SelectSubset<T, PayrollRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PayrollRun.
     * @param {PayrollRunUpsertArgs} args - Arguments to update or create a PayrollRun.
     * @example
     * // Update or create a PayrollRun
     * const payrollRun = await prisma.payrollRun.upsert({
     *   create: {
     *     // ... data to create a PayrollRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollRun we want to update
     *   }
     * })
     */
    upsert<T extends PayrollRunUpsertArgs>(args: SelectSubset<T, PayrollRunUpsertArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PayrollRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunCountArgs} args - Arguments to filter PayrollRuns to count.
     * @example
     * // Count the number of PayrollRuns
     * const count = await prisma.payrollRun.count({
     *   where: {
     *     // ... the filter for the PayrollRuns we want to count
     *   }
     * })
    **/
    count<T extends PayrollRunCountArgs>(
      args?: Subset<T, PayrollRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollRunAggregateArgs>(args: Subset<T, PayrollRunAggregateArgs>): Prisma.PrismaPromise<GetPayrollRunAggregateType<T>>

    /**
     * Group by PayrollRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollRunGroupByArgs['orderBy'] }
        : { orderBy?: PayrollRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollRun model
   */
  readonly fields: PayrollRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends PayrollRun$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PayrollRun$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollRun model
   */ 
  interface PayrollRunFieldRefs {
    readonly id: FieldRef<"PayrollRun", 'Int'>
    readonly periodStart: FieldRef<"PayrollRun", 'DateTime'>
    readonly periodEnd: FieldRef<"PayrollRun", 'DateTime'>
    readonly status: FieldRef<"PayrollRun", 'String'>
    readonly createdBy: FieldRef<"PayrollRun", 'Int'>
    readonly createdAt: FieldRef<"PayrollRun", 'DateTime'>
    readonly approvedBy: FieldRef<"PayrollRun", 'Int'>
    readonly approvedAt: FieldRef<"PayrollRun", 'DateTime'>
    readonly lockedAt: FieldRef<"PayrollRun", 'DateTime'>
    readonly totalGross: FieldRef<"PayrollRun", 'Float'>
    readonly totalNet: FieldRef<"PayrollRun", 'Float'>
    readonly totalDeductions: FieldRef<"PayrollRun", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * PayrollRun findUnique
   */
  export type PayrollRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRun to fetch.
     */
    where: PayrollRunWhereUniqueInput
  }

  /**
   * PayrollRun findUniqueOrThrow
   */
  export type PayrollRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRun to fetch.
     */
    where: PayrollRunWhereUniqueInput
  }

  /**
   * PayrollRun findFirst
   */
  export type PayrollRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRun to fetch.
     */
    where?: PayrollRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRuns to fetch.
     */
    orderBy?: PayrollRunOrderByWithRelationInput | PayrollRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollRuns.
     */
    cursor?: PayrollRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollRuns.
     */
    distinct?: PayrollRunScalarFieldEnum | PayrollRunScalarFieldEnum[]
  }

  /**
   * PayrollRun findFirstOrThrow
   */
  export type PayrollRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRun to fetch.
     */
    where?: PayrollRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRuns to fetch.
     */
    orderBy?: PayrollRunOrderByWithRelationInput | PayrollRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollRuns.
     */
    cursor?: PayrollRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollRuns.
     */
    distinct?: PayrollRunScalarFieldEnum | PayrollRunScalarFieldEnum[]
  }

  /**
   * PayrollRun findMany
   */
  export type PayrollRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRuns to fetch.
     */
    where?: PayrollRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRuns to fetch.
     */
    orderBy?: PayrollRunOrderByWithRelationInput | PayrollRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollRuns.
     */
    cursor?: PayrollRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRuns.
     */
    skip?: number
    distinct?: PayrollRunScalarFieldEnum | PayrollRunScalarFieldEnum[]
  }

  /**
   * PayrollRun create
   */
  export type PayrollRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollRun.
     */
    data: XOR<PayrollRunCreateInput, PayrollRunUncheckedCreateInput>
  }

  /**
   * PayrollRun createMany
   */
  export type PayrollRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollRuns.
     */
    data: PayrollRunCreateManyInput | PayrollRunCreateManyInput[]
  }

  /**
   * PayrollRun createManyAndReturn
   */
  export type PayrollRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PayrollRuns.
     */
    data: PayrollRunCreateManyInput | PayrollRunCreateManyInput[]
  }

  /**
   * PayrollRun update
   */
  export type PayrollRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollRun.
     */
    data: XOR<PayrollRunUpdateInput, PayrollRunUncheckedUpdateInput>
    /**
     * Choose, which PayrollRun to update.
     */
    where: PayrollRunWhereUniqueInput
  }

  /**
   * PayrollRun updateMany
   */
  export type PayrollRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollRuns.
     */
    data: XOR<PayrollRunUpdateManyMutationInput, PayrollRunUncheckedUpdateManyInput>
    /**
     * Filter which PayrollRuns to update
     */
    where?: PayrollRunWhereInput
  }

  /**
   * PayrollRun upsert
   */
  export type PayrollRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollRun to update in case it exists.
     */
    where: PayrollRunWhereUniqueInput
    /**
     * In case the PayrollRun found by the `where` argument doesn't exist, create a new PayrollRun with this data.
     */
    create: XOR<PayrollRunCreateInput, PayrollRunUncheckedCreateInput>
    /**
     * In case the PayrollRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollRunUpdateInput, PayrollRunUncheckedUpdateInput>
  }

  /**
   * PayrollRun delete
   */
  export type PayrollRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
    /**
     * Filter which PayrollRun to delete.
     */
    where: PayrollRunWhereUniqueInput
  }

  /**
   * PayrollRun deleteMany
   */
  export type PayrollRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollRuns to delete
     */
    where?: PayrollRunWhereInput
  }

  /**
   * PayrollRun.items
   */
  export type PayrollRun$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    where?: PayrollItemWhereInput
    orderBy?: PayrollItemOrderByWithRelationInput | PayrollItemOrderByWithRelationInput[]
    cursor?: PayrollItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollItemScalarFieldEnum | PayrollItemScalarFieldEnum[]
  }

  /**
   * PayrollRun without action
   */
  export type PayrollRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRun
     */
    select?: PayrollRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollRunInclude<ExtArgs> | null
  }


  /**
   * Model PayrollItem
   */

  export type AggregatePayrollItem = {
    _count: PayrollItemCountAggregateOutputType | null
    _avg: PayrollItemAvgAggregateOutputType | null
    _sum: PayrollItemSumAggregateOutputType | null
    _min: PayrollItemMinAggregateOutputType | null
    _max: PayrollItemMaxAggregateOutputType | null
  }

  export type PayrollItemAvgAggregateOutputType = {
    id: number | null
    payrollRunId: number | null
    employeeId: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
    otherAllow: number | null
    overtimePay: number | null
    grossPay: number | null
    advanceDeduction: number | null
    loanDeduction: number | null
    unpaidLeaveDeduction: number | null
    otherDeductions: number | null
    totalDeductions: number | null
    netPay: number | null
  }

  export type PayrollItemSumAggregateOutputType = {
    id: number | null
    payrollRunId: number | null
    employeeId: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
    otherAllow: number | null
    overtimePay: number | null
    grossPay: number | null
    advanceDeduction: number | null
    loanDeduction: number | null
    unpaidLeaveDeduction: number | null
    otherDeductions: number | null
    totalDeductions: number | null
    netPay: number | null
  }

  export type PayrollItemMinAggregateOutputType = {
    id: number | null
    payrollRunId: number | null
    employeeId: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
    otherAllow: number | null
    overtimePay: number | null
    grossPay: number | null
    advanceDeduction: number | null
    loanDeduction: number | null
    unpaidLeaveDeduction: number | null
    otherDeductions: number | null
    totalDeductions: number | null
    netPay: number | null
    iban: string | null
    wpsStatus: string | null
  }

  export type PayrollItemMaxAggregateOutputType = {
    id: number | null
    payrollRunId: number | null
    employeeId: number | null
    basicSalary: number | null
    housingAllow: number | null
    transportAllow: number | null
    otherAllow: number | null
    overtimePay: number | null
    grossPay: number | null
    advanceDeduction: number | null
    loanDeduction: number | null
    unpaidLeaveDeduction: number | null
    otherDeductions: number | null
    totalDeductions: number | null
    netPay: number | null
    iban: string | null
    wpsStatus: string | null
  }

  export type PayrollItemCountAggregateOutputType = {
    id: number
    payrollRunId: number
    employeeId: number
    basicSalary: number
    housingAllow: number
    transportAllow: number
    otherAllow: number
    overtimePay: number
    grossPay: number
    advanceDeduction: number
    loanDeduction: number
    unpaidLeaveDeduction: number
    otherDeductions: number
    totalDeductions: number
    netPay: number
    iban: number
    wpsStatus: number
    _all: number
  }


  export type PayrollItemAvgAggregateInputType = {
    id?: true
    payrollRunId?: true
    employeeId?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
    otherAllow?: true
    overtimePay?: true
    grossPay?: true
    advanceDeduction?: true
    loanDeduction?: true
    unpaidLeaveDeduction?: true
    otherDeductions?: true
    totalDeductions?: true
    netPay?: true
  }

  export type PayrollItemSumAggregateInputType = {
    id?: true
    payrollRunId?: true
    employeeId?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
    otherAllow?: true
    overtimePay?: true
    grossPay?: true
    advanceDeduction?: true
    loanDeduction?: true
    unpaidLeaveDeduction?: true
    otherDeductions?: true
    totalDeductions?: true
    netPay?: true
  }

  export type PayrollItemMinAggregateInputType = {
    id?: true
    payrollRunId?: true
    employeeId?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
    otherAllow?: true
    overtimePay?: true
    grossPay?: true
    advanceDeduction?: true
    loanDeduction?: true
    unpaidLeaveDeduction?: true
    otherDeductions?: true
    totalDeductions?: true
    netPay?: true
    iban?: true
    wpsStatus?: true
  }

  export type PayrollItemMaxAggregateInputType = {
    id?: true
    payrollRunId?: true
    employeeId?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
    otherAllow?: true
    overtimePay?: true
    grossPay?: true
    advanceDeduction?: true
    loanDeduction?: true
    unpaidLeaveDeduction?: true
    otherDeductions?: true
    totalDeductions?: true
    netPay?: true
    iban?: true
    wpsStatus?: true
  }

  export type PayrollItemCountAggregateInputType = {
    id?: true
    payrollRunId?: true
    employeeId?: true
    basicSalary?: true
    housingAllow?: true
    transportAllow?: true
    otherAllow?: true
    overtimePay?: true
    grossPay?: true
    advanceDeduction?: true
    loanDeduction?: true
    unpaidLeaveDeduction?: true
    otherDeductions?: true
    totalDeductions?: true
    netPay?: true
    iban?: true
    wpsStatus?: true
    _all?: true
  }

  export type PayrollItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollItem to aggregate.
     */
    where?: PayrollItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollItems to fetch.
     */
    orderBy?: PayrollItemOrderByWithRelationInput | PayrollItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollItems
    **/
    _count?: true | PayrollItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollItemMaxAggregateInputType
  }

  export type GetPayrollItemAggregateType<T extends PayrollItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollItem[P]>
      : GetScalarType<T[P], AggregatePayrollItem[P]>
  }




  export type PayrollItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollItemWhereInput
    orderBy?: PayrollItemOrderByWithAggregationInput | PayrollItemOrderByWithAggregationInput[]
    by: PayrollItemScalarFieldEnum[] | PayrollItemScalarFieldEnum
    having?: PayrollItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollItemCountAggregateInputType | true
    _avg?: PayrollItemAvgAggregateInputType
    _sum?: PayrollItemSumAggregateInputType
    _min?: PayrollItemMinAggregateInputType
    _max?: PayrollItemMaxAggregateInputType
  }

  export type PayrollItemGroupByOutputType = {
    id: number
    payrollRunId: number
    employeeId: number
    basicSalary: number
    housingAllow: number | null
    transportAllow: number | null
    otherAllow: number | null
    overtimePay: number | null
    grossPay: number
    advanceDeduction: number | null
    loanDeduction: number | null
    unpaidLeaveDeduction: number | null
    otherDeductions: number | null
    totalDeductions: number
    netPay: number
    iban: string | null
    wpsStatus: string | null
    _count: PayrollItemCountAggregateOutputType | null
    _avg: PayrollItemAvgAggregateOutputType | null
    _sum: PayrollItemSumAggregateOutputType | null
    _min: PayrollItemMinAggregateOutputType | null
    _max: PayrollItemMaxAggregateOutputType | null
  }

  type GetPayrollItemGroupByPayload<T extends PayrollItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollItemGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollItemGroupByOutputType[P]>
        }
      >
    >


  export type PayrollItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payrollRunId?: boolean
    employeeId?: boolean
    basicSalary?: boolean
    housingAllow?: boolean
    transportAllow?: boolean
    otherAllow?: boolean
    overtimePay?: boolean
    grossPay?: boolean
    advanceDeduction?: boolean
    loanDeduction?: boolean
    unpaidLeaveDeduction?: boolean
    otherDeductions?: boolean
    totalDeductions?: boolean
    netPay?: boolean
    iban?: boolean
    wpsStatus?: boolean
    payrollRun?: boolean | PayrollRunDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollItem"]>

  export type PayrollItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payrollRunId?: boolean
    employeeId?: boolean
    basicSalary?: boolean
    housingAllow?: boolean
    transportAllow?: boolean
    otherAllow?: boolean
    overtimePay?: boolean
    grossPay?: boolean
    advanceDeduction?: boolean
    loanDeduction?: boolean
    unpaidLeaveDeduction?: boolean
    otherDeductions?: boolean
    totalDeductions?: boolean
    netPay?: boolean
    iban?: boolean
    wpsStatus?: boolean
    payrollRun?: boolean | PayrollRunDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollItem"]>

  export type PayrollItemSelectScalar = {
    id?: boolean
    payrollRunId?: boolean
    employeeId?: boolean
    basicSalary?: boolean
    housingAllow?: boolean
    transportAllow?: boolean
    otherAllow?: boolean
    overtimePay?: boolean
    grossPay?: boolean
    advanceDeduction?: boolean
    loanDeduction?: boolean
    unpaidLeaveDeduction?: boolean
    otherDeductions?: boolean
    totalDeductions?: boolean
    netPay?: boolean
    iban?: boolean
    wpsStatus?: boolean
  }

  export type PayrollItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payrollRun?: boolean | PayrollRunDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payrollRun?: boolean | PayrollRunDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollItem"
    objects: {
      payrollRun: Prisma.$PayrollRunPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      payrollRunId: number
      employeeId: number
      basicSalary: number
      housingAllow: number | null
      transportAllow: number | null
      otherAllow: number | null
      overtimePay: number | null
      grossPay: number
      advanceDeduction: number | null
      loanDeduction: number | null
      unpaidLeaveDeduction: number | null
      otherDeductions: number | null
      totalDeductions: number
      netPay: number
      iban: string | null
      wpsStatus: string | null
    }, ExtArgs["result"]["payrollItem"]>
    composites: {}
  }

  type PayrollItemGetPayload<S extends boolean | null | undefined | PayrollItemDefaultArgs> = $Result.GetResult<Prisma.$PayrollItemPayload, S>

  type PayrollItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayrollItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayrollItemCountAggregateInputType | true
    }

  export interface PayrollItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollItem'], meta: { name: 'PayrollItem' } }
    /**
     * Find zero or one PayrollItem that matches the filter.
     * @param {PayrollItemFindUniqueArgs} args - Arguments to find a PayrollItem
     * @example
     * // Get one PayrollItem
     * const payrollItem = await prisma.payrollItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollItemFindUniqueArgs>(args: SelectSubset<T, PayrollItemFindUniqueArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PayrollItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayrollItemFindUniqueOrThrowArgs} args - Arguments to find a PayrollItem
     * @example
     * // Get one PayrollItem
     * const payrollItem = await prisma.payrollItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PayrollItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemFindFirstArgs} args - Arguments to find a PayrollItem
     * @example
     * // Get one PayrollItem
     * const payrollItem = await prisma.payrollItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollItemFindFirstArgs>(args?: SelectSubset<T, PayrollItemFindFirstArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PayrollItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemFindFirstOrThrowArgs} args - Arguments to find a PayrollItem
     * @example
     * // Get one PayrollItem
     * const payrollItem = await prisma.payrollItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PayrollItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollItems
     * const payrollItems = await prisma.payrollItem.findMany()
     * 
     * // Get first 10 PayrollItems
     * const payrollItems = await prisma.payrollItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollItemWithIdOnly = await prisma.payrollItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollItemFindManyArgs>(args?: SelectSubset<T, PayrollItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PayrollItem.
     * @param {PayrollItemCreateArgs} args - Arguments to create a PayrollItem.
     * @example
     * // Create one PayrollItem
     * const PayrollItem = await prisma.payrollItem.create({
     *   data: {
     *     // ... data to create a PayrollItem
     *   }
     * })
     * 
     */
    create<T extends PayrollItemCreateArgs>(args: SelectSubset<T, PayrollItemCreateArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PayrollItems.
     * @param {PayrollItemCreateManyArgs} args - Arguments to create many PayrollItems.
     * @example
     * // Create many PayrollItems
     * const payrollItem = await prisma.payrollItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollItemCreateManyArgs>(args?: SelectSubset<T, PayrollItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollItems and returns the data saved in the database.
     * @param {PayrollItemCreateManyAndReturnArgs} args - Arguments to create many PayrollItems.
     * @example
     * // Create many PayrollItems
     * const payrollItem = await prisma.payrollItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollItems and only return the `id`
     * const payrollItemWithIdOnly = await prisma.payrollItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PayrollItem.
     * @param {PayrollItemDeleteArgs} args - Arguments to delete one PayrollItem.
     * @example
     * // Delete one PayrollItem
     * const PayrollItem = await prisma.payrollItem.delete({
     *   where: {
     *     // ... filter to delete one PayrollItem
     *   }
     * })
     * 
     */
    delete<T extends PayrollItemDeleteArgs>(args: SelectSubset<T, PayrollItemDeleteArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PayrollItem.
     * @param {PayrollItemUpdateArgs} args - Arguments to update one PayrollItem.
     * @example
     * // Update one PayrollItem
     * const payrollItem = await prisma.payrollItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollItemUpdateArgs>(args: SelectSubset<T, PayrollItemUpdateArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PayrollItems.
     * @param {PayrollItemDeleteManyArgs} args - Arguments to filter PayrollItems to delete.
     * @example
     * // Delete a few PayrollItems
     * const { count } = await prisma.payrollItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollItemDeleteManyArgs>(args?: SelectSubset<T, PayrollItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollItems
     * const payrollItem = await prisma.payrollItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollItemUpdateManyArgs>(args: SelectSubset<T, PayrollItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PayrollItem.
     * @param {PayrollItemUpsertArgs} args - Arguments to update or create a PayrollItem.
     * @example
     * // Update or create a PayrollItem
     * const payrollItem = await prisma.payrollItem.upsert({
     *   create: {
     *     // ... data to create a PayrollItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollItem we want to update
     *   }
     * })
     */
    upsert<T extends PayrollItemUpsertArgs>(args: SelectSubset<T, PayrollItemUpsertArgs<ExtArgs>>): Prisma__PayrollItemClient<$Result.GetResult<Prisma.$PayrollItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PayrollItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemCountArgs} args - Arguments to filter PayrollItems to count.
     * @example
     * // Count the number of PayrollItems
     * const count = await prisma.payrollItem.count({
     *   where: {
     *     // ... the filter for the PayrollItems we want to count
     *   }
     * })
    **/
    count<T extends PayrollItemCountArgs>(
      args?: Subset<T, PayrollItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollItemAggregateArgs>(args: Subset<T, PayrollItemAggregateArgs>): Prisma.PrismaPromise<GetPayrollItemAggregateType<T>>

    /**
     * Group by PayrollItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollItemGroupByArgs['orderBy'] }
        : { orderBy?: PayrollItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollItem model
   */
  readonly fields: PayrollItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payrollRun<T extends PayrollRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollRunDefaultArgs<ExtArgs>>): Prisma__PayrollRunClient<$Result.GetResult<Prisma.$PayrollRunPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollItem model
   */ 
  interface PayrollItemFieldRefs {
    readonly id: FieldRef<"PayrollItem", 'Int'>
    readonly payrollRunId: FieldRef<"PayrollItem", 'Int'>
    readonly employeeId: FieldRef<"PayrollItem", 'Int'>
    readonly basicSalary: FieldRef<"PayrollItem", 'Float'>
    readonly housingAllow: FieldRef<"PayrollItem", 'Float'>
    readonly transportAllow: FieldRef<"PayrollItem", 'Float'>
    readonly otherAllow: FieldRef<"PayrollItem", 'Float'>
    readonly overtimePay: FieldRef<"PayrollItem", 'Float'>
    readonly grossPay: FieldRef<"PayrollItem", 'Float'>
    readonly advanceDeduction: FieldRef<"PayrollItem", 'Float'>
    readonly loanDeduction: FieldRef<"PayrollItem", 'Float'>
    readonly unpaidLeaveDeduction: FieldRef<"PayrollItem", 'Float'>
    readonly otherDeductions: FieldRef<"PayrollItem", 'Float'>
    readonly totalDeductions: FieldRef<"PayrollItem", 'Float'>
    readonly netPay: FieldRef<"PayrollItem", 'Float'>
    readonly iban: FieldRef<"PayrollItem", 'String'>
    readonly wpsStatus: FieldRef<"PayrollItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PayrollItem findUnique
   */
  export type PayrollItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * Filter, which PayrollItem to fetch.
     */
    where: PayrollItemWhereUniqueInput
  }

  /**
   * PayrollItem findUniqueOrThrow
   */
  export type PayrollItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * Filter, which PayrollItem to fetch.
     */
    where: PayrollItemWhereUniqueInput
  }

  /**
   * PayrollItem findFirst
   */
  export type PayrollItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * Filter, which PayrollItem to fetch.
     */
    where?: PayrollItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollItems to fetch.
     */
    orderBy?: PayrollItemOrderByWithRelationInput | PayrollItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollItems.
     */
    cursor?: PayrollItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollItems.
     */
    distinct?: PayrollItemScalarFieldEnum | PayrollItemScalarFieldEnum[]
  }

  /**
   * PayrollItem findFirstOrThrow
   */
  export type PayrollItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * Filter, which PayrollItem to fetch.
     */
    where?: PayrollItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollItems to fetch.
     */
    orderBy?: PayrollItemOrderByWithRelationInput | PayrollItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollItems.
     */
    cursor?: PayrollItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollItems.
     */
    distinct?: PayrollItemScalarFieldEnum | PayrollItemScalarFieldEnum[]
  }

  /**
   * PayrollItem findMany
   */
  export type PayrollItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * Filter, which PayrollItems to fetch.
     */
    where?: PayrollItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollItems to fetch.
     */
    orderBy?: PayrollItemOrderByWithRelationInput | PayrollItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollItems.
     */
    cursor?: PayrollItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollItems.
     */
    skip?: number
    distinct?: PayrollItemScalarFieldEnum | PayrollItemScalarFieldEnum[]
  }

  /**
   * PayrollItem create
   */
  export type PayrollItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollItem.
     */
    data: XOR<PayrollItemCreateInput, PayrollItemUncheckedCreateInput>
  }

  /**
   * PayrollItem createMany
   */
  export type PayrollItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollItems.
     */
    data: PayrollItemCreateManyInput | PayrollItemCreateManyInput[]
  }

  /**
   * PayrollItem createManyAndReturn
   */
  export type PayrollItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PayrollItems.
     */
    data: PayrollItemCreateManyInput | PayrollItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollItem update
   */
  export type PayrollItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollItem.
     */
    data: XOR<PayrollItemUpdateInput, PayrollItemUncheckedUpdateInput>
    /**
     * Choose, which PayrollItem to update.
     */
    where: PayrollItemWhereUniqueInput
  }

  /**
   * PayrollItem updateMany
   */
  export type PayrollItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollItems.
     */
    data: XOR<PayrollItemUpdateManyMutationInput, PayrollItemUncheckedUpdateManyInput>
    /**
     * Filter which PayrollItems to update
     */
    where?: PayrollItemWhereInput
  }

  /**
   * PayrollItem upsert
   */
  export type PayrollItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollItem to update in case it exists.
     */
    where: PayrollItemWhereUniqueInput
    /**
     * In case the PayrollItem found by the `where` argument doesn't exist, create a new PayrollItem with this data.
     */
    create: XOR<PayrollItemCreateInput, PayrollItemUncheckedCreateInput>
    /**
     * In case the PayrollItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollItemUpdateInput, PayrollItemUncheckedUpdateInput>
  }

  /**
   * PayrollItem delete
   */
  export type PayrollItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
    /**
     * Filter which PayrollItem to delete.
     */
    where: PayrollItemWhereUniqueInput
  }

  /**
   * PayrollItem deleteMany
   */
  export type PayrollItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollItems to delete
     */
    where?: PayrollItemWhereInput
  }

  /**
   * PayrollItem without action
   */
  export type PayrollItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollItem
     */
    select?: PayrollItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollItemInclude<ExtArgs> | null
  }


  /**
   * Model FinalSettlement
   */

  export type AggregateFinalSettlement = {
    _count: FinalSettlementCountAggregateOutputType | null
    _avg: FinalSettlementAvgAggregateOutputType | null
    _sum: FinalSettlementSumAggregateOutputType | null
    _min: FinalSettlementMinAggregateOutputType | null
    _max: FinalSettlementMaxAggregateOutputType | null
  }

  export type FinalSettlementAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    yearsWorked: number | null
    eosbAmount: number | null
    unusedLeaveDays: number | null
    unusedLeavePay: number | null
    otherDues: number | null
    totalSettlement: number | null
    approvedBy: number | null
  }

  export type FinalSettlementSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    yearsWorked: number | null
    eosbAmount: number | null
    unusedLeaveDays: number | null
    unusedLeavePay: number | null
    otherDues: number | null
    totalSettlement: number | null
    approvedBy: number | null
  }

  export type FinalSettlementMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    terminationDate: Date | null
    terminationType: string | null
    lastWorkingDay: Date | null
    yearsWorked: number | null
    eosbAmount: number | null
    unusedLeaveDays: number | null
    unusedLeavePay: number | null
    otherDues: number | null
    totalSettlement: number | null
    status: string | null
    approvedBy: number | null
    approvedAt: Date | null
    paidDate: Date | null
  }

  export type FinalSettlementMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    terminationDate: Date | null
    terminationType: string | null
    lastWorkingDay: Date | null
    yearsWorked: number | null
    eosbAmount: number | null
    unusedLeaveDays: number | null
    unusedLeavePay: number | null
    otherDues: number | null
    totalSettlement: number | null
    status: string | null
    approvedBy: number | null
    approvedAt: Date | null
    paidDate: Date | null
  }

  export type FinalSettlementCountAggregateOutputType = {
    id: number
    employeeId: number
    terminationDate: number
    terminationType: number
    lastWorkingDay: number
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues: number
    totalSettlement: number
    status: number
    approvedBy: number
    approvedAt: number
    paidDate: number
    _all: number
  }


  export type FinalSettlementAvgAggregateInputType = {
    id?: true
    employeeId?: true
    yearsWorked?: true
    eosbAmount?: true
    unusedLeaveDays?: true
    unusedLeavePay?: true
    otherDues?: true
    totalSettlement?: true
    approvedBy?: true
  }

  export type FinalSettlementSumAggregateInputType = {
    id?: true
    employeeId?: true
    yearsWorked?: true
    eosbAmount?: true
    unusedLeaveDays?: true
    unusedLeavePay?: true
    otherDues?: true
    totalSettlement?: true
    approvedBy?: true
  }

  export type FinalSettlementMinAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    terminationType?: true
    lastWorkingDay?: true
    yearsWorked?: true
    eosbAmount?: true
    unusedLeaveDays?: true
    unusedLeavePay?: true
    otherDues?: true
    totalSettlement?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    paidDate?: true
  }

  export type FinalSettlementMaxAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    terminationType?: true
    lastWorkingDay?: true
    yearsWorked?: true
    eosbAmount?: true
    unusedLeaveDays?: true
    unusedLeavePay?: true
    otherDues?: true
    totalSettlement?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    paidDate?: true
  }

  export type FinalSettlementCountAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    terminationType?: true
    lastWorkingDay?: true
    yearsWorked?: true
    eosbAmount?: true
    unusedLeaveDays?: true
    unusedLeavePay?: true
    otherDues?: true
    totalSettlement?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    paidDate?: true
    _all?: true
  }

  export type FinalSettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalSettlement to aggregate.
     */
    where?: FinalSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalSettlements to fetch.
     */
    orderBy?: FinalSettlementOrderByWithRelationInput | FinalSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinalSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinalSettlements
    **/
    _count?: true | FinalSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinalSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinalSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinalSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinalSettlementMaxAggregateInputType
  }

  export type GetFinalSettlementAggregateType<T extends FinalSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateFinalSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinalSettlement[P]>
      : GetScalarType<T[P], AggregateFinalSettlement[P]>
  }




  export type FinalSettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalSettlementWhereInput
    orderBy?: FinalSettlementOrderByWithAggregationInput | FinalSettlementOrderByWithAggregationInput[]
    by: FinalSettlementScalarFieldEnum[] | FinalSettlementScalarFieldEnum
    having?: FinalSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinalSettlementCountAggregateInputType | true
    _avg?: FinalSettlementAvgAggregateInputType
    _sum?: FinalSettlementSumAggregateInputType
    _min?: FinalSettlementMinAggregateInputType
    _max?: FinalSettlementMaxAggregateInputType
  }

  export type FinalSettlementGroupByOutputType = {
    id: number
    employeeId: number
    terminationDate: Date
    terminationType: string
    lastWorkingDay: Date
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues: number | null
    totalSettlement: number
    status: string
    approvedBy: number | null
    approvedAt: Date | null
    paidDate: Date | null
    _count: FinalSettlementCountAggregateOutputType | null
    _avg: FinalSettlementAvgAggregateOutputType | null
    _sum: FinalSettlementSumAggregateOutputType | null
    _min: FinalSettlementMinAggregateOutputType | null
    _max: FinalSettlementMaxAggregateOutputType | null
  }

  type GetFinalSettlementGroupByPayload<T extends FinalSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinalSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinalSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinalSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], FinalSettlementGroupByOutputType[P]>
        }
      >
    >


  export type FinalSettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    terminationType?: boolean
    lastWorkingDay?: boolean
    yearsWorked?: boolean
    eosbAmount?: boolean
    unusedLeaveDays?: boolean
    unusedLeavePay?: boolean
    otherDues?: boolean
    totalSettlement?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    paidDate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalSettlement"]>

  export type FinalSettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    terminationType?: boolean
    lastWorkingDay?: boolean
    yearsWorked?: boolean
    eosbAmount?: boolean
    unusedLeaveDays?: boolean
    unusedLeavePay?: boolean
    otherDues?: boolean
    totalSettlement?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    paidDate?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalSettlement"]>

  export type FinalSettlementSelectScalar = {
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    terminationType?: boolean
    lastWorkingDay?: boolean
    yearsWorked?: boolean
    eosbAmount?: boolean
    unusedLeaveDays?: boolean
    unusedLeavePay?: boolean
    otherDues?: boolean
    totalSettlement?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    paidDate?: boolean
  }

  export type FinalSettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type FinalSettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $FinalSettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinalSettlement"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      terminationDate: Date
      terminationType: string
      lastWorkingDay: Date
      yearsWorked: number
      eosbAmount: number
      unusedLeaveDays: number
      unusedLeavePay: number
      otherDues: number | null
      totalSettlement: number
      status: string
      approvedBy: number | null
      approvedAt: Date | null
      paidDate: Date | null
    }, ExtArgs["result"]["finalSettlement"]>
    composites: {}
  }

  type FinalSettlementGetPayload<S extends boolean | null | undefined | FinalSettlementDefaultArgs> = $Result.GetResult<Prisma.$FinalSettlementPayload, S>

  type FinalSettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinalSettlementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinalSettlementCountAggregateInputType | true
    }

  export interface FinalSettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinalSettlement'], meta: { name: 'FinalSettlement' } }
    /**
     * Find zero or one FinalSettlement that matches the filter.
     * @param {FinalSettlementFindUniqueArgs} args - Arguments to find a FinalSettlement
     * @example
     * // Get one FinalSettlement
     * const finalSettlement = await prisma.finalSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinalSettlementFindUniqueArgs>(args: SelectSubset<T, FinalSettlementFindUniqueArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinalSettlement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinalSettlementFindUniqueOrThrowArgs} args - Arguments to find a FinalSettlement
     * @example
     * // Get one FinalSettlement
     * const finalSettlement = await prisma.finalSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinalSettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, FinalSettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinalSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementFindFirstArgs} args - Arguments to find a FinalSettlement
     * @example
     * // Get one FinalSettlement
     * const finalSettlement = await prisma.finalSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinalSettlementFindFirstArgs>(args?: SelectSubset<T, FinalSettlementFindFirstArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinalSettlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementFindFirstOrThrowArgs} args - Arguments to find a FinalSettlement
     * @example
     * // Get one FinalSettlement
     * const finalSettlement = await prisma.finalSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinalSettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, FinalSettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinalSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinalSettlements
     * const finalSettlements = await prisma.finalSettlement.findMany()
     * 
     * // Get first 10 FinalSettlements
     * const finalSettlements = await prisma.finalSettlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const finalSettlementWithIdOnly = await prisma.finalSettlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinalSettlementFindManyArgs>(args?: SelectSubset<T, FinalSettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinalSettlement.
     * @param {FinalSettlementCreateArgs} args - Arguments to create a FinalSettlement.
     * @example
     * // Create one FinalSettlement
     * const FinalSettlement = await prisma.finalSettlement.create({
     *   data: {
     *     // ... data to create a FinalSettlement
     *   }
     * })
     * 
     */
    create<T extends FinalSettlementCreateArgs>(args: SelectSubset<T, FinalSettlementCreateArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinalSettlements.
     * @param {FinalSettlementCreateManyArgs} args - Arguments to create many FinalSettlements.
     * @example
     * // Create many FinalSettlements
     * const finalSettlement = await prisma.finalSettlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinalSettlementCreateManyArgs>(args?: SelectSubset<T, FinalSettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinalSettlements and returns the data saved in the database.
     * @param {FinalSettlementCreateManyAndReturnArgs} args - Arguments to create many FinalSettlements.
     * @example
     * // Create many FinalSettlements
     * const finalSettlement = await prisma.finalSettlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinalSettlements and only return the `id`
     * const finalSettlementWithIdOnly = await prisma.finalSettlement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinalSettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, FinalSettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinalSettlement.
     * @param {FinalSettlementDeleteArgs} args - Arguments to delete one FinalSettlement.
     * @example
     * // Delete one FinalSettlement
     * const FinalSettlement = await prisma.finalSettlement.delete({
     *   where: {
     *     // ... filter to delete one FinalSettlement
     *   }
     * })
     * 
     */
    delete<T extends FinalSettlementDeleteArgs>(args: SelectSubset<T, FinalSettlementDeleteArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinalSettlement.
     * @param {FinalSettlementUpdateArgs} args - Arguments to update one FinalSettlement.
     * @example
     * // Update one FinalSettlement
     * const finalSettlement = await prisma.finalSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinalSettlementUpdateArgs>(args: SelectSubset<T, FinalSettlementUpdateArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinalSettlements.
     * @param {FinalSettlementDeleteManyArgs} args - Arguments to filter FinalSettlements to delete.
     * @example
     * // Delete a few FinalSettlements
     * const { count } = await prisma.finalSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinalSettlementDeleteManyArgs>(args?: SelectSubset<T, FinalSettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinalSettlements
     * const finalSettlement = await prisma.finalSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinalSettlementUpdateManyArgs>(args: SelectSubset<T, FinalSettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinalSettlement.
     * @param {FinalSettlementUpsertArgs} args - Arguments to update or create a FinalSettlement.
     * @example
     * // Update or create a FinalSettlement
     * const finalSettlement = await prisma.finalSettlement.upsert({
     *   create: {
     *     // ... data to create a FinalSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinalSettlement we want to update
     *   }
     * })
     */
    upsert<T extends FinalSettlementUpsertArgs>(args: SelectSubset<T, FinalSettlementUpsertArgs<ExtArgs>>): Prisma__FinalSettlementClient<$Result.GetResult<Prisma.$FinalSettlementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinalSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementCountArgs} args - Arguments to filter FinalSettlements to count.
     * @example
     * // Count the number of FinalSettlements
     * const count = await prisma.finalSettlement.count({
     *   where: {
     *     // ... the filter for the FinalSettlements we want to count
     *   }
     * })
    **/
    count<T extends FinalSettlementCountArgs>(
      args?: Subset<T, FinalSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinalSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinalSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinalSettlementAggregateArgs>(args: Subset<T, FinalSettlementAggregateArgs>): Prisma.PrismaPromise<GetFinalSettlementAggregateType<T>>

    /**
     * Group by FinalSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinalSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinalSettlementGroupByArgs['orderBy'] }
        : { orderBy?: FinalSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinalSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinalSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinalSettlement model
   */
  readonly fields: FinalSettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinalSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinalSettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinalSettlement model
   */ 
  interface FinalSettlementFieldRefs {
    readonly id: FieldRef<"FinalSettlement", 'Int'>
    readonly employeeId: FieldRef<"FinalSettlement", 'Int'>
    readonly terminationDate: FieldRef<"FinalSettlement", 'DateTime'>
    readonly terminationType: FieldRef<"FinalSettlement", 'String'>
    readonly lastWorkingDay: FieldRef<"FinalSettlement", 'DateTime'>
    readonly yearsWorked: FieldRef<"FinalSettlement", 'Float'>
    readonly eosbAmount: FieldRef<"FinalSettlement", 'Float'>
    readonly unusedLeaveDays: FieldRef<"FinalSettlement", 'Int'>
    readonly unusedLeavePay: FieldRef<"FinalSettlement", 'Float'>
    readonly otherDues: FieldRef<"FinalSettlement", 'Float'>
    readonly totalSettlement: FieldRef<"FinalSettlement", 'Float'>
    readonly status: FieldRef<"FinalSettlement", 'String'>
    readonly approvedBy: FieldRef<"FinalSettlement", 'Int'>
    readonly approvedAt: FieldRef<"FinalSettlement", 'DateTime'>
    readonly paidDate: FieldRef<"FinalSettlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinalSettlement findUnique
   */
  export type FinalSettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * Filter, which FinalSettlement to fetch.
     */
    where: FinalSettlementWhereUniqueInput
  }

  /**
   * FinalSettlement findUniqueOrThrow
   */
  export type FinalSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * Filter, which FinalSettlement to fetch.
     */
    where: FinalSettlementWhereUniqueInput
  }

  /**
   * FinalSettlement findFirst
   */
  export type FinalSettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * Filter, which FinalSettlement to fetch.
     */
    where?: FinalSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalSettlements to fetch.
     */
    orderBy?: FinalSettlementOrderByWithRelationInput | FinalSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalSettlements.
     */
    cursor?: FinalSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalSettlements.
     */
    distinct?: FinalSettlementScalarFieldEnum | FinalSettlementScalarFieldEnum[]
  }

  /**
   * FinalSettlement findFirstOrThrow
   */
  export type FinalSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * Filter, which FinalSettlement to fetch.
     */
    where?: FinalSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalSettlements to fetch.
     */
    orderBy?: FinalSettlementOrderByWithRelationInput | FinalSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalSettlements.
     */
    cursor?: FinalSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalSettlements.
     */
    distinct?: FinalSettlementScalarFieldEnum | FinalSettlementScalarFieldEnum[]
  }

  /**
   * FinalSettlement findMany
   */
  export type FinalSettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * Filter, which FinalSettlements to fetch.
     */
    where?: FinalSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalSettlements to fetch.
     */
    orderBy?: FinalSettlementOrderByWithRelationInput | FinalSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinalSettlements.
     */
    cursor?: FinalSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalSettlements.
     */
    skip?: number
    distinct?: FinalSettlementScalarFieldEnum | FinalSettlementScalarFieldEnum[]
  }

  /**
   * FinalSettlement create
   */
  export type FinalSettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a FinalSettlement.
     */
    data: XOR<FinalSettlementCreateInput, FinalSettlementUncheckedCreateInput>
  }

  /**
   * FinalSettlement createMany
   */
  export type FinalSettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinalSettlements.
     */
    data: FinalSettlementCreateManyInput | FinalSettlementCreateManyInput[]
  }

  /**
   * FinalSettlement createManyAndReturn
   */
  export type FinalSettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinalSettlements.
     */
    data: FinalSettlementCreateManyInput | FinalSettlementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalSettlement update
   */
  export type FinalSettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a FinalSettlement.
     */
    data: XOR<FinalSettlementUpdateInput, FinalSettlementUncheckedUpdateInput>
    /**
     * Choose, which FinalSettlement to update.
     */
    where: FinalSettlementWhereUniqueInput
  }

  /**
   * FinalSettlement updateMany
   */
  export type FinalSettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinalSettlements.
     */
    data: XOR<FinalSettlementUpdateManyMutationInput, FinalSettlementUncheckedUpdateManyInput>
    /**
     * Filter which FinalSettlements to update
     */
    where?: FinalSettlementWhereInput
  }

  /**
   * FinalSettlement upsert
   */
  export type FinalSettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the FinalSettlement to update in case it exists.
     */
    where: FinalSettlementWhereUniqueInput
    /**
     * In case the FinalSettlement found by the `where` argument doesn't exist, create a new FinalSettlement with this data.
     */
    create: XOR<FinalSettlementCreateInput, FinalSettlementUncheckedCreateInput>
    /**
     * In case the FinalSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinalSettlementUpdateInput, FinalSettlementUncheckedUpdateInput>
  }

  /**
   * FinalSettlement delete
   */
  export type FinalSettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
    /**
     * Filter which FinalSettlement to delete.
     */
    where: FinalSettlementWhereUniqueInput
  }

  /**
   * FinalSettlement deleteMany
   */
  export type FinalSettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalSettlements to delete
     */
    where?: FinalSettlementWhereInput
  }

  /**
   * FinalSettlement without action
   */
  export type FinalSettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalSettlement
     */
    select?: FinalSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalSettlementInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    role: 'role',
    employeeId: 'employeeId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeCode: 'employeeCode',
    name: 'name',
    nameEn: 'nameEn',
    nationalId: 'nationalId',
    email: 'email',
    phone: 'phone',
    iqamaNumber: 'iqamaNumber',
    iqamaExpiry: 'iqamaExpiry',
    passportNumber: 'passportNumber',
    passportExpiry: 'passportExpiry',
    nationality: 'nationality',
    bankName: 'bankName',
    iban: 'iban',
    workPermitNumber: 'workPermitNumber',
    workPermitExpiry: 'workPermitExpiry',
    medicalInsuranceExpiry: 'medicalInsuranceExpiry',
    joinDate: 'joinDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    startDate: 'startDate',
    endDate: 'endDate',
    salary: 'salary',
    leaveDays: 'leaveDays',
    leaveMoney: 'leaveMoney',
    contractType: 'contractType',
    probationDays: 'probationDays',
    basicSalary: 'basicSalary',
    housingAllow: 'housingAllow',
    transportAllow: 'transportAllow'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    daysCount: 'daysCount',
    paid: 'paid',
    paidAmount: 'paidAmount',
    status: 'status',
    requestDate: 'requestDate',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedReason: 'rejectedReason',
    sickPayRate: 'sickPayRate'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const TravelTicketScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    year: 'year',
    issued: 'issued',
    issueDate: 'issueDate'
  };

  export type TravelTicketScalarFieldEnum = (typeof TravelTicketScalarFieldEnum)[keyof typeof TravelTicketScalarFieldEnum]


  export const AdvanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    amount: 'amount',
    date: 'date',
    status: 'status'
  };

  export type AdvanceScalarFieldEnum = (typeof AdvanceScalarFieldEnum)[keyof typeof AdvanceScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    assetType: 'assetType',
    description: 'description',
    assignedDate: 'assignedDate',
    returned: 'returned',
    returnDate: 'returnDate'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    checkIn: 'checkIn',
    checkOut: 'checkOut'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const EntitlementScalarFieldEnum: {
    id: 'id',
    yearsWorked: 'yearsWorked',
    fraction: 'fraction',
    terminationType: 'terminationType',
    paid: 'paid',
    paidDate: 'paidDate',
    employeeId: 'employeeId',
    type: 'type',
    amount: 'amount',
    calculatedAt: 'calculatedAt'
  };

  export type EntitlementScalarFieldEnum = (typeof EntitlementScalarFieldEnum)[keyof typeof EntitlementScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    docType: 'docType',
    expiryDate: 'expiryDate',
    number: 'number'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    before: 'before',
    after: 'after',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const PayrollRunScalarFieldEnum: {
    id: 'id',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    lockedAt: 'lockedAt',
    totalGross: 'totalGross',
    totalNet: 'totalNet',
    totalDeductions: 'totalDeductions'
  };

  export type PayrollRunScalarFieldEnum = (typeof PayrollRunScalarFieldEnum)[keyof typeof PayrollRunScalarFieldEnum]


  export const PayrollItemScalarFieldEnum: {
    id: 'id',
    payrollRunId: 'payrollRunId',
    employeeId: 'employeeId',
    basicSalary: 'basicSalary',
    housingAllow: 'housingAllow',
    transportAllow: 'transportAllow',
    otherAllow: 'otherAllow',
    overtimePay: 'overtimePay',
    grossPay: 'grossPay',
    advanceDeduction: 'advanceDeduction',
    loanDeduction: 'loanDeduction',
    unpaidLeaveDeduction: 'unpaidLeaveDeduction',
    otherDeductions: 'otherDeductions',
    totalDeductions: 'totalDeductions',
    netPay: 'netPay',
    iban: 'iban',
    wpsStatus: 'wpsStatus'
  };

  export type PayrollItemScalarFieldEnum = (typeof PayrollItemScalarFieldEnum)[keyof typeof PayrollItemScalarFieldEnum]


  export const FinalSettlementScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    terminationDate: 'terminationDate',
    terminationType: 'terminationType',
    lastWorkingDay: 'lastWorkingDay',
    yearsWorked: 'yearsWorked',
    eosbAmount: 'eosbAmount',
    unusedLeaveDays: 'unusedLeaveDays',
    unusedLeavePay: 'unusedLeavePay',
    otherDues: 'otherDues',
    totalSettlement: 'totalSettlement',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    paidDate: 'paidDate'
  };

  export type FinalSettlementScalarFieldEnum = (typeof FinalSettlementScalarFieldEnum)[keyof typeof FinalSettlementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    employeeId?: IntNullableFilter<"User"> | number | null
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    employeeId?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }, "id" | "username" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    employeeId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    employeeCode?: StringNullableFilter<"Employee"> | string | null
    name?: StringFilter<"Employee"> | string
    nameEn?: StringNullableFilter<"Employee"> | string | null
    nationalId?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    iqamaNumber?: StringNullableFilter<"Employee"> | string | null
    iqamaExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    passportNumber?: StringNullableFilter<"Employee"> | string | null
    passportExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    bankName?: StringNullableFilter<"Employee"> | string | null
    iban?: StringNullableFilter<"Employee"> | string | null
    workPermitNumber?: StringNullableFilter<"Employee"> | string | null
    workPermitExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    medicalInsuranceExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    joinDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    contracts?: ContractListRelationFilter
    leaves?: LeaveListRelationFilter
    travelTickets?: TravelTicketListRelationFilter
    advances?: AdvanceListRelationFilter
    assets?: AssetListRelationFilter
    attendances?: AttendanceListRelationFilter
    entitlements?: EntitlementListRelationFilter
    documents?: DocumentListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    payrollItems?: PayrollItemListRelationFilter
    finalSettlements?: FinalSettlementListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeCode?: SortOrderInput | SortOrder
    name?: SortOrder
    nameEn?: SortOrderInput | SortOrder
    nationalId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    iqamaNumber?: SortOrderInput | SortOrder
    iqamaExpiry?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    iban?: SortOrderInput | SortOrder
    workPermitNumber?: SortOrderInput | SortOrder
    workPermitExpiry?: SortOrderInput | SortOrder
    medicalInsuranceExpiry?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contracts?: ContractOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    travelTickets?: TravelTicketOrderByRelationAggregateInput
    advances?: AdvanceOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    entitlements?: EntitlementOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    payrollItems?: PayrollItemOrderByRelationAggregateInput
    finalSettlements?: FinalSettlementOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeCode?: string
    nationalId?: string
    email?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    nameEn?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    iqamaNumber?: StringNullableFilter<"Employee"> | string | null
    iqamaExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    passportNumber?: StringNullableFilter<"Employee"> | string | null
    passportExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    bankName?: StringNullableFilter<"Employee"> | string | null
    iban?: StringNullableFilter<"Employee"> | string | null
    workPermitNumber?: StringNullableFilter<"Employee"> | string | null
    workPermitExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    medicalInsuranceExpiry?: DateTimeNullableFilter<"Employee"> | Date | string | null
    joinDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    contracts?: ContractListRelationFilter
    leaves?: LeaveListRelationFilter
    travelTickets?: TravelTicketListRelationFilter
    advances?: AdvanceListRelationFilter
    assets?: AssetListRelationFilter
    attendances?: AttendanceListRelationFilter
    entitlements?: EntitlementListRelationFilter
    documents?: DocumentListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    payrollItems?: PayrollItemListRelationFilter
    finalSettlements?: FinalSettlementListRelationFilter
  }, "id" | "employeeCode" | "nationalId" | "email">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeCode?: SortOrderInput | SortOrder
    name?: SortOrder
    nameEn?: SortOrderInput | SortOrder
    nationalId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    iqamaNumber?: SortOrderInput | SortOrder
    iqamaExpiry?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    iban?: SortOrderInput | SortOrder
    workPermitNumber?: SortOrderInput | SortOrder
    workPermitExpiry?: SortOrderInput | SortOrder
    medicalInsuranceExpiry?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    employeeCode?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    name?: StringWithAggregatesFilter<"Employee"> | string
    nameEn?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    nationalId?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    iqamaNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    iqamaExpiry?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    passportNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    passportExpiry?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    nationality?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    iban?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    workPermitNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    workPermitExpiry?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    medicalInsuranceExpiry?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    joinDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: IntFilter<"Contract"> | number
    employeeId?: IntFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    salary?: FloatFilter<"Contract"> | number
    leaveDays?: IntFilter<"Contract"> | number
    leaveMoney?: FloatFilter<"Contract"> | number
    contractType?: StringFilter<"Contract"> | string
    probationDays?: IntNullableFilter<"Contract"> | number | null
    basicSalary?: FloatNullableFilter<"Contract"> | number | null
    housingAllow?: FloatNullableFilter<"Contract"> | number | null
    transportAllow?: FloatNullableFilter<"Contract"> | number | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    contractType?: SortOrder
    probationDays?: SortOrderInput | SortOrder
    basicSalary?: SortOrderInput | SortOrder
    housingAllow?: SortOrderInput | SortOrder
    transportAllow?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    employeeId?: IntFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    salary?: FloatFilter<"Contract"> | number
    leaveDays?: IntFilter<"Contract"> | number
    leaveMoney?: FloatFilter<"Contract"> | number
    contractType?: StringFilter<"Contract"> | string
    probationDays?: IntNullableFilter<"Contract"> | number | null
    basicSalary?: FloatNullableFilter<"Contract"> | number | null
    housingAllow?: FloatNullableFilter<"Contract"> | number | null
    transportAllow?: FloatNullableFilter<"Contract"> | number | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    contractType?: SortOrder
    probationDays?: SortOrderInput | SortOrder
    basicSalary?: SortOrderInput | SortOrder
    housingAllow?: SortOrderInput | SortOrder
    transportAllow?: SortOrderInput | SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contract"> | number
    employeeId?: IntWithAggregatesFilter<"Contract"> | number
    startDate?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    salary?: FloatWithAggregatesFilter<"Contract"> | number
    leaveDays?: IntWithAggregatesFilter<"Contract"> | number
    leaveMoney?: FloatWithAggregatesFilter<"Contract"> | number
    contractType?: StringWithAggregatesFilter<"Contract"> | string
    probationDays?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    basicSalary?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    housingAllow?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
    transportAllow?: FloatNullableWithAggregatesFilter<"Contract"> | number | null
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: IntFilter<"Leave"> | number
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    daysCount?: IntFilter<"Leave"> | number
    paid?: BoolFilter<"Leave"> | boolean
    paidAmount?: FloatNullableFilter<"Leave"> | number | null
    status?: StringFilter<"Leave"> | string
    requestDate?: DateTimeFilter<"Leave"> | Date | string
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    rejectedReason?: StringNullableFilter<"Leave"> | string | null
    sickPayRate?: FloatNullableFilter<"Leave"> | number | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    daysCount?: SortOrder
    paid?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    sickPayRate?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    daysCount?: IntFilter<"Leave"> | number
    paid?: BoolFilter<"Leave"> | boolean
    paidAmount?: FloatNullableFilter<"Leave"> | number | null
    status?: StringFilter<"Leave"> | string
    requestDate?: DateTimeFilter<"Leave"> | Date | string
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    rejectedReason?: StringNullableFilter<"Leave"> | string | null
    sickPayRate?: FloatNullableFilter<"Leave"> | number | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    daysCount?: SortOrder
    paid?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedReason?: SortOrderInput | SortOrder
    sickPayRate?: SortOrderInput | SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave"> | number
    employeeId?: IntWithAggregatesFilter<"Leave"> | number
    leaveType?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    daysCount?: IntWithAggregatesFilter<"Leave"> | number
    paid?: BoolWithAggregatesFilter<"Leave"> | boolean
    paidAmount?: FloatNullableWithAggregatesFilter<"Leave"> | number | null
    status?: StringWithAggregatesFilter<"Leave"> | string
    requestDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    approvedBy?: IntNullableWithAggregatesFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Leave"> | Date | string | null
    rejectedReason?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    sickPayRate?: FloatNullableWithAggregatesFilter<"Leave"> | number | null
  }

  export type TravelTicketWhereInput = {
    AND?: TravelTicketWhereInput | TravelTicketWhereInput[]
    OR?: TravelTicketWhereInput[]
    NOT?: TravelTicketWhereInput | TravelTicketWhereInput[]
    id?: IntFilter<"TravelTicket"> | number
    employeeId?: IntFilter<"TravelTicket"> | number
    year?: IntFilter<"TravelTicket"> | number
    issued?: BoolFilter<"TravelTicket"> | boolean
    issueDate?: DateTimeNullableFilter<"TravelTicket"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type TravelTicketOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    issued?: SortOrder
    issueDate?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type TravelTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TravelTicketWhereInput | TravelTicketWhereInput[]
    OR?: TravelTicketWhereInput[]
    NOT?: TravelTicketWhereInput | TravelTicketWhereInput[]
    employeeId?: IntFilter<"TravelTicket"> | number
    year?: IntFilter<"TravelTicket"> | number
    issued?: BoolFilter<"TravelTicket"> | boolean
    issueDate?: DateTimeNullableFilter<"TravelTicket"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type TravelTicketOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    issued?: SortOrder
    issueDate?: SortOrderInput | SortOrder
    _count?: TravelTicketCountOrderByAggregateInput
    _avg?: TravelTicketAvgOrderByAggregateInput
    _max?: TravelTicketMaxOrderByAggregateInput
    _min?: TravelTicketMinOrderByAggregateInput
    _sum?: TravelTicketSumOrderByAggregateInput
  }

  export type TravelTicketScalarWhereWithAggregatesInput = {
    AND?: TravelTicketScalarWhereWithAggregatesInput | TravelTicketScalarWhereWithAggregatesInput[]
    OR?: TravelTicketScalarWhereWithAggregatesInput[]
    NOT?: TravelTicketScalarWhereWithAggregatesInput | TravelTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TravelTicket"> | number
    employeeId?: IntWithAggregatesFilter<"TravelTicket"> | number
    year?: IntWithAggregatesFilter<"TravelTicket"> | number
    issued?: BoolWithAggregatesFilter<"TravelTicket"> | boolean
    issueDate?: DateTimeNullableWithAggregatesFilter<"TravelTicket"> | Date | string | null
  }

  export type AdvanceWhereInput = {
    AND?: AdvanceWhereInput | AdvanceWhereInput[]
    OR?: AdvanceWhereInput[]
    NOT?: AdvanceWhereInput | AdvanceWhereInput[]
    id?: IntFilter<"Advance"> | number
    employeeId?: IntFilter<"Advance"> | number
    amount?: FloatFilter<"Advance"> | number
    date?: DateTimeFilter<"Advance"> | Date | string
    status?: StringFilter<"Advance"> | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type AdvanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    status?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AdvanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdvanceWhereInput | AdvanceWhereInput[]
    OR?: AdvanceWhereInput[]
    NOT?: AdvanceWhereInput | AdvanceWhereInput[]
    employeeId?: IntFilter<"Advance"> | number
    amount?: FloatFilter<"Advance"> | number
    date?: DateTimeFilter<"Advance"> | Date | string
    status?: StringFilter<"Advance"> | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AdvanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: AdvanceCountOrderByAggregateInput
    _avg?: AdvanceAvgOrderByAggregateInput
    _max?: AdvanceMaxOrderByAggregateInput
    _min?: AdvanceMinOrderByAggregateInput
    _sum?: AdvanceSumOrderByAggregateInput
  }

  export type AdvanceScalarWhereWithAggregatesInput = {
    AND?: AdvanceScalarWhereWithAggregatesInput | AdvanceScalarWhereWithAggregatesInput[]
    OR?: AdvanceScalarWhereWithAggregatesInput[]
    NOT?: AdvanceScalarWhereWithAggregatesInput | AdvanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Advance"> | number
    employeeId?: IntWithAggregatesFilter<"Advance"> | number
    amount?: FloatWithAggregatesFilter<"Advance"> | number
    date?: DateTimeWithAggregatesFilter<"Advance"> | Date | string
    status?: StringWithAggregatesFilter<"Advance"> | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: IntFilter<"Asset"> | number
    employeeId?: IntFilter<"Asset"> | number
    assetType?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    assignedDate?: DateTimeFilter<"Asset"> | Date | string
    returned?: BoolFilter<"Asset"> | boolean
    returnDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assetType?: SortOrder
    description?: SortOrderInput | SortOrder
    assignedDate?: SortOrder
    returned?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    employeeId?: IntFilter<"Asset"> | number
    assetType?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    assignedDate?: DateTimeFilter<"Asset"> | Date | string
    returned?: BoolFilter<"Asset"> | boolean
    returnDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assetType?: SortOrder
    description?: SortOrderInput | SortOrder
    assignedDate?: SortOrder
    returned?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Asset"> | number
    employeeId?: IntWithAggregatesFilter<"Asset"> | number
    assetType?: StringWithAggregatesFilter<"Asset"> | string
    description?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    assignedDate?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    returned?: BoolWithAggregatesFilter<"Asset"> | boolean
    returnDate?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: IntFilter<"Attendance"> | number
    employeeId?: IntFilter<"Attendance"> | number
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrderInput | SortOrder
    checkOut?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    employeeId?: IntFilter<"Attendance"> | number
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrderInput | SortOrder
    checkOut?: SortOrderInput | SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendance"> | number
    employeeId?: IntWithAggregatesFilter<"Attendance"> | number
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    checkIn?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    checkOut?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
  }

  export type EntitlementWhereInput = {
    AND?: EntitlementWhereInput | EntitlementWhereInput[]
    OR?: EntitlementWhereInput[]
    NOT?: EntitlementWhereInput | EntitlementWhereInput[]
    id?: IntFilter<"Entitlement"> | number
    yearsWorked?: FloatNullableFilter<"Entitlement"> | number | null
    fraction?: FloatNullableFilter<"Entitlement"> | number | null
    terminationType?: StringNullableFilter<"Entitlement"> | string | null
    paid?: BoolFilter<"Entitlement"> | boolean
    paidDate?: DateTimeNullableFilter<"Entitlement"> | Date | string | null
    employeeId?: IntFilter<"Entitlement"> | number
    type?: StringFilter<"Entitlement"> | string
    amount?: FloatFilter<"Entitlement"> | number
    calculatedAt?: DateTimeFilter<"Entitlement"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type EntitlementOrderByWithRelationInput = {
    id?: SortOrder
    yearsWorked?: SortOrderInput | SortOrder
    fraction?: SortOrderInput | SortOrder
    terminationType?: SortOrderInput | SortOrder
    paid?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    calculatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type EntitlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntitlementWhereInput | EntitlementWhereInput[]
    OR?: EntitlementWhereInput[]
    NOT?: EntitlementWhereInput | EntitlementWhereInput[]
    yearsWorked?: FloatNullableFilter<"Entitlement"> | number | null
    fraction?: FloatNullableFilter<"Entitlement"> | number | null
    terminationType?: StringNullableFilter<"Entitlement"> | string | null
    paid?: BoolFilter<"Entitlement"> | boolean
    paidDate?: DateTimeNullableFilter<"Entitlement"> | Date | string | null
    employeeId?: IntFilter<"Entitlement"> | number
    type?: StringFilter<"Entitlement"> | string
    amount?: FloatFilter<"Entitlement"> | number
    calculatedAt?: DateTimeFilter<"Entitlement"> | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type EntitlementOrderByWithAggregationInput = {
    id?: SortOrder
    yearsWorked?: SortOrderInput | SortOrder
    fraction?: SortOrderInput | SortOrder
    terminationType?: SortOrderInput | SortOrder
    paid?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    calculatedAt?: SortOrder
    _count?: EntitlementCountOrderByAggregateInput
    _avg?: EntitlementAvgOrderByAggregateInput
    _max?: EntitlementMaxOrderByAggregateInput
    _min?: EntitlementMinOrderByAggregateInput
    _sum?: EntitlementSumOrderByAggregateInput
  }

  export type EntitlementScalarWhereWithAggregatesInput = {
    AND?: EntitlementScalarWhereWithAggregatesInput | EntitlementScalarWhereWithAggregatesInput[]
    OR?: EntitlementScalarWhereWithAggregatesInput[]
    NOT?: EntitlementScalarWhereWithAggregatesInput | EntitlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entitlement"> | number
    yearsWorked?: FloatNullableWithAggregatesFilter<"Entitlement"> | number | null
    fraction?: FloatNullableWithAggregatesFilter<"Entitlement"> | number | null
    terminationType?: StringNullableWithAggregatesFilter<"Entitlement"> | string | null
    paid?: BoolWithAggregatesFilter<"Entitlement"> | boolean
    paidDate?: DateTimeNullableWithAggregatesFilter<"Entitlement"> | Date | string | null
    employeeId?: IntWithAggregatesFilter<"Entitlement"> | number
    type?: StringWithAggregatesFilter<"Entitlement"> | string
    amount?: FloatWithAggregatesFilter<"Entitlement"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"Entitlement"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: IntFilter<"Document"> | number
    employeeId?: IntFilter<"Document"> | number
    docType?: StringFilter<"Document"> | string
    expiryDate?: DateTimeFilter<"Document"> | Date | string
    number?: StringNullableFilter<"Document"> | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    docType?: SortOrder
    expiryDate?: SortOrder
    number?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    employeeId?: IntFilter<"Document"> | number
    docType?: StringFilter<"Document"> | string
    expiryDate?: DateTimeFilter<"Document"> | Date | string
    number?: StringNullableFilter<"Document"> | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    docType?: SortOrder
    expiryDate?: SortOrder
    number?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Document"> | number
    employeeId?: IntWithAggregatesFilter<"Document"> | number
    docType?: StringWithAggregatesFilter<"Document"> | string
    expiryDate?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    number?: StringNullableWithAggregatesFilter<"Document"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    before?: StringNullableFilter<"AuditLog"> | string | null
    after?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: IntFilter<"AuditLog"> | number
    before?: StringNullableFilter<"AuditLog"> | string | null
    after?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: IntWithAggregatesFilter<"AuditLog"> | number
    before?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    after?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type PayrollRunWhereInput = {
    AND?: PayrollRunWhereInput | PayrollRunWhereInput[]
    OR?: PayrollRunWhereInput[]
    NOT?: PayrollRunWhereInput | PayrollRunWhereInput[]
    id?: IntFilter<"PayrollRun"> | number
    periodStart?: DateTimeFilter<"PayrollRun"> | Date | string
    periodEnd?: DateTimeFilter<"PayrollRun"> | Date | string
    status?: StringFilter<"PayrollRun"> | string
    createdBy?: IntFilter<"PayrollRun"> | number
    createdAt?: DateTimeFilter<"PayrollRun"> | Date | string
    approvedBy?: IntNullableFilter<"PayrollRun"> | number | null
    approvedAt?: DateTimeNullableFilter<"PayrollRun"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"PayrollRun"> | Date | string | null
    totalGross?: FloatNullableFilter<"PayrollRun"> | number | null
    totalNet?: FloatNullableFilter<"PayrollRun"> | number | null
    totalDeductions?: FloatNullableFilter<"PayrollRun"> | number | null
    items?: PayrollItemListRelationFilter
  }

  export type PayrollRunOrderByWithRelationInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    totalGross?: SortOrderInput | SortOrder
    totalNet?: SortOrderInput | SortOrder
    totalDeductions?: SortOrderInput | SortOrder
    items?: PayrollItemOrderByRelationAggregateInput
  }

  export type PayrollRunWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PayrollRunWhereInput | PayrollRunWhereInput[]
    OR?: PayrollRunWhereInput[]
    NOT?: PayrollRunWhereInput | PayrollRunWhereInput[]
    periodStart?: DateTimeFilter<"PayrollRun"> | Date | string
    periodEnd?: DateTimeFilter<"PayrollRun"> | Date | string
    status?: StringFilter<"PayrollRun"> | string
    createdBy?: IntFilter<"PayrollRun"> | number
    createdAt?: DateTimeFilter<"PayrollRun"> | Date | string
    approvedBy?: IntNullableFilter<"PayrollRun"> | number | null
    approvedAt?: DateTimeNullableFilter<"PayrollRun"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"PayrollRun"> | Date | string | null
    totalGross?: FloatNullableFilter<"PayrollRun"> | number | null
    totalNet?: FloatNullableFilter<"PayrollRun"> | number | null
    totalDeductions?: FloatNullableFilter<"PayrollRun"> | number | null
    items?: PayrollItemListRelationFilter
  }, "id">

  export type PayrollRunOrderByWithAggregationInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    totalGross?: SortOrderInput | SortOrder
    totalNet?: SortOrderInput | SortOrder
    totalDeductions?: SortOrderInput | SortOrder
    _count?: PayrollRunCountOrderByAggregateInput
    _avg?: PayrollRunAvgOrderByAggregateInput
    _max?: PayrollRunMaxOrderByAggregateInput
    _min?: PayrollRunMinOrderByAggregateInput
    _sum?: PayrollRunSumOrderByAggregateInput
  }

  export type PayrollRunScalarWhereWithAggregatesInput = {
    AND?: PayrollRunScalarWhereWithAggregatesInput | PayrollRunScalarWhereWithAggregatesInput[]
    OR?: PayrollRunScalarWhereWithAggregatesInput[]
    NOT?: PayrollRunScalarWhereWithAggregatesInput | PayrollRunScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PayrollRun"> | number
    periodStart?: DateTimeWithAggregatesFilter<"PayrollRun"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"PayrollRun"> | Date | string
    status?: StringWithAggregatesFilter<"PayrollRun"> | string
    createdBy?: IntWithAggregatesFilter<"PayrollRun"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PayrollRun"> | Date | string
    approvedBy?: IntNullableWithAggregatesFilter<"PayrollRun"> | number | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PayrollRun"> | Date | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"PayrollRun"> | Date | string | null
    totalGross?: FloatNullableWithAggregatesFilter<"PayrollRun"> | number | null
    totalNet?: FloatNullableWithAggregatesFilter<"PayrollRun"> | number | null
    totalDeductions?: FloatNullableWithAggregatesFilter<"PayrollRun"> | number | null
  }

  export type PayrollItemWhereInput = {
    AND?: PayrollItemWhereInput | PayrollItemWhereInput[]
    OR?: PayrollItemWhereInput[]
    NOT?: PayrollItemWhereInput | PayrollItemWhereInput[]
    id?: IntFilter<"PayrollItem"> | number
    payrollRunId?: IntFilter<"PayrollItem"> | number
    employeeId?: IntFilter<"PayrollItem"> | number
    basicSalary?: FloatFilter<"PayrollItem"> | number
    housingAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    transportAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    otherAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    overtimePay?: FloatNullableFilter<"PayrollItem"> | number | null
    grossPay?: FloatFilter<"PayrollItem"> | number
    advanceDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    loanDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    unpaidLeaveDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    otherDeductions?: FloatNullableFilter<"PayrollItem"> | number | null
    totalDeductions?: FloatFilter<"PayrollItem"> | number
    netPay?: FloatFilter<"PayrollItem"> | number
    iban?: StringNullableFilter<"PayrollItem"> | string | null
    wpsStatus?: StringNullableFilter<"PayrollItem"> | string | null
    payrollRun?: XOR<PayrollRunRelationFilter, PayrollRunWhereInput>
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type PayrollItemOrderByWithRelationInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrderInput | SortOrder
    transportAllow?: SortOrderInput | SortOrder
    otherAllow?: SortOrderInput | SortOrder
    overtimePay?: SortOrderInput | SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrderInput | SortOrder
    loanDeduction?: SortOrderInput | SortOrder
    unpaidLeaveDeduction?: SortOrderInput | SortOrder
    otherDeductions?: SortOrderInput | SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
    iban?: SortOrderInput | SortOrder
    wpsStatus?: SortOrderInput | SortOrder
    payrollRun?: PayrollRunOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PayrollItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PayrollItemWhereInput | PayrollItemWhereInput[]
    OR?: PayrollItemWhereInput[]
    NOT?: PayrollItemWhereInput | PayrollItemWhereInput[]
    payrollRunId?: IntFilter<"PayrollItem"> | number
    employeeId?: IntFilter<"PayrollItem"> | number
    basicSalary?: FloatFilter<"PayrollItem"> | number
    housingAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    transportAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    otherAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    overtimePay?: FloatNullableFilter<"PayrollItem"> | number | null
    grossPay?: FloatFilter<"PayrollItem"> | number
    advanceDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    loanDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    unpaidLeaveDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    otherDeductions?: FloatNullableFilter<"PayrollItem"> | number | null
    totalDeductions?: FloatFilter<"PayrollItem"> | number
    netPay?: FloatFilter<"PayrollItem"> | number
    iban?: StringNullableFilter<"PayrollItem"> | string | null
    wpsStatus?: StringNullableFilter<"PayrollItem"> | string | null
    payrollRun?: XOR<PayrollRunRelationFilter, PayrollRunWhereInput>
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PayrollItemOrderByWithAggregationInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrderInput | SortOrder
    transportAllow?: SortOrderInput | SortOrder
    otherAllow?: SortOrderInput | SortOrder
    overtimePay?: SortOrderInput | SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrderInput | SortOrder
    loanDeduction?: SortOrderInput | SortOrder
    unpaidLeaveDeduction?: SortOrderInput | SortOrder
    otherDeductions?: SortOrderInput | SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
    iban?: SortOrderInput | SortOrder
    wpsStatus?: SortOrderInput | SortOrder
    _count?: PayrollItemCountOrderByAggregateInput
    _avg?: PayrollItemAvgOrderByAggregateInput
    _max?: PayrollItemMaxOrderByAggregateInput
    _min?: PayrollItemMinOrderByAggregateInput
    _sum?: PayrollItemSumOrderByAggregateInput
  }

  export type PayrollItemScalarWhereWithAggregatesInput = {
    AND?: PayrollItemScalarWhereWithAggregatesInput | PayrollItemScalarWhereWithAggregatesInput[]
    OR?: PayrollItemScalarWhereWithAggregatesInput[]
    NOT?: PayrollItemScalarWhereWithAggregatesInput | PayrollItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PayrollItem"> | number
    payrollRunId?: IntWithAggregatesFilter<"PayrollItem"> | number
    employeeId?: IntWithAggregatesFilter<"PayrollItem"> | number
    basicSalary?: FloatWithAggregatesFilter<"PayrollItem"> | number
    housingAllow?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    transportAllow?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    otherAllow?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    overtimePay?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    grossPay?: FloatWithAggregatesFilter<"PayrollItem"> | number
    advanceDeduction?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    loanDeduction?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    unpaidLeaveDeduction?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    otherDeductions?: FloatNullableWithAggregatesFilter<"PayrollItem"> | number | null
    totalDeductions?: FloatWithAggregatesFilter<"PayrollItem"> | number
    netPay?: FloatWithAggregatesFilter<"PayrollItem"> | number
    iban?: StringNullableWithAggregatesFilter<"PayrollItem"> | string | null
    wpsStatus?: StringNullableWithAggregatesFilter<"PayrollItem"> | string | null
  }

  export type FinalSettlementWhereInput = {
    AND?: FinalSettlementWhereInput | FinalSettlementWhereInput[]
    OR?: FinalSettlementWhereInput[]
    NOT?: FinalSettlementWhereInput | FinalSettlementWhereInput[]
    id?: IntFilter<"FinalSettlement"> | number
    employeeId?: IntFilter<"FinalSettlement"> | number
    terminationDate?: DateTimeFilter<"FinalSettlement"> | Date | string
    terminationType?: StringFilter<"FinalSettlement"> | string
    lastWorkingDay?: DateTimeFilter<"FinalSettlement"> | Date | string
    yearsWorked?: FloatFilter<"FinalSettlement"> | number
    eosbAmount?: FloatFilter<"FinalSettlement"> | number
    unusedLeaveDays?: IntFilter<"FinalSettlement"> | number
    unusedLeavePay?: FloatFilter<"FinalSettlement"> | number
    otherDues?: FloatNullableFilter<"FinalSettlement"> | number | null
    totalSettlement?: FloatFilter<"FinalSettlement"> | number
    status?: StringFilter<"FinalSettlement"> | string
    approvedBy?: IntNullableFilter<"FinalSettlement"> | number | null
    approvedAt?: DateTimeNullableFilter<"FinalSettlement"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"FinalSettlement"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type FinalSettlementOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    terminationType?: SortOrder
    lastWorkingDay?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrderInput | SortOrder
    totalSettlement?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    paidDate?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type FinalSettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FinalSettlementWhereInput | FinalSettlementWhereInput[]
    OR?: FinalSettlementWhereInput[]
    NOT?: FinalSettlementWhereInput | FinalSettlementWhereInput[]
    employeeId?: IntFilter<"FinalSettlement"> | number
    terminationDate?: DateTimeFilter<"FinalSettlement"> | Date | string
    terminationType?: StringFilter<"FinalSettlement"> | string
    lastWorkingDay?: DateTimeFilter<"FinalSettlement"> | Date | string
    yearsWorked?: FloatFilter<"FinalSettlement"> | number
    eosbAmount?: FloatFilter<"FinalSettlement"> | number
    unusedLeaveDays?: IntFilter<"FinalSettlement"> | number
    unusedLeavePay?: FloatFilter<"FinalSettlement"> | number
    otherDues?: FloatNullableFilter<"FinalSettlement"> | number | null
    totalSettlement?: FloatFilter<"FinalSettlement"> | number
    status?: StringFilter<"FinalSettlement"> | string
    approvedBy?: IntNullableFilter<"FinalSettlement"> | number | null
    approvedAt?: DateTimeNullableFilter<"FinalSettlement"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"FinalSettlement"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type FinalSettlementOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    terminationType?: SortOrder
    lastWorkingDay?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrderInput | SortOrder
    totalSettlement?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    paidDate?: SortOrderInput | SortOrder
    _count?: FinalSettlementCountOrderByAggregateInput
    _avg?: FinalSettlementAvgOrderByAggregateInput
    _max?: FinalSettlementMaxOrderByAggregateInput
    _min?: FinalSettlementMinOrderByAggregateInput
    _sum?: FinalSettlementSumOrderByAggregateInput
  }

  export type FinalSettlementScalarWhereWithAggregatesInput = {
    AND?: FinalSettlementScalarWhereWithAggregatesInput | FinalSettlementScalarWhereWithAggregatesInput[]
    OR?: FinalSettlementScalarWhereWithAggregatesInput[]
    NOT?: FinalSettlementScalarWhereWithAggregatesInput | FinalSettlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FinalSettlement"> | number
    employeeId?: IntWithAggregatesFilter<"FinalSettlement"> | number
    terminationDate?: DateTimeWithAggregatesFilter<"FinalSettlement"> | Date | string
    terminationType?: StringWithAggregatesFilter<"FinalSettlement"> | string
    lastWorkingDay?: DateTimeWithAggregatesFilter<"FinalSettlement"> | Date | string
    yearsWorked?: FloatWithAggregatesFilter<"FinalSettlement"> | number
    eosbAmount?: FloatWithAggregatesFilter<"FinalSettlement"> | number
    unusedLeaveDays?: IntWithAggregatesFilter<"FinalSettlement"> | number
    unusedLeavePay?: FloatWithAggregatesFilter<"FinalSettlement"> | number
    otherDues?: FloatNullableWithAggregatesFilter<"FinalSettlement"> | number | null
    totalSettlement?: FloatWithAggregatesFilter<"FinalSettlement"> | number
    status?: StringWithAggregatesFilter<"FinalSettlement"> | string
    approvedBy?: IntNullableWithAggregatesFilter<"FinalSettlement"> | number | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"FinalSettlement"> | Date | string | null
    paidDate?: DateTimeNullableWithAggregatesFilter<"FinalSettlement"> | Date | string | null
  }

  export type UserCreateInput = {
    username: string
    password: string
    role: string
    employee?: EmployeeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    role: string
    employeeId?: number | null
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    role: string
    employeeId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeCreateInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    startDate: Date | string
    endDate?: Date | string | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays?: number | null
    basicSalary?: number | null
    housingAllow?: number | null
    transportAllow?: number | null
    employee: EmployeeCreateNestedOneWithoutContractsInput
  }

  export type ContractUncheckedCreateInput = {
    id?: number
    employeeId: number
    startDate: Date | string
    endDate?: Date | string | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays?: number | null
    basicSalary?: number | null
    housingAllow?: number | null
    transportAllow?: number | null
  }

  export type ContractUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ContractCreateManyInput = {
    id?: number
    employeeId: number
    startDate: Date | string
    endDate?: Date | string | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays?: number | null
    basicSalary?: number | null
    housingAllow?: number | null
    transportAllow?: number | null
  }

  export type ContractUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveCreateInput = {
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    daysCount: number
    paid: boolean
    paidAmount?: number | null
    status: string
    requestDate?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    sickPayRate?: number | null
    employee: EmployeeCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: number
    employeeId: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    daysCount: number
    paid: boolean
    paidAmount?: number | null
    status: string
    requestDate?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    sickPayRate?: number | null
  }

  export type LeaveUpdateInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveCreateManyInput = {
    id?: number
    employeeId: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    daysCount: number
    paid: boolean
    paidAmount?: number | null
    status: string
    requestDate?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    sickPayRate?: number | null
  }

  export type LeaveUpdateManyMutationInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TravelTicketCreateInput = {
    year: number
    issued?: boolean
    issueDate?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutTravelTicketsInput
  }

  export type TravelTicketUncheckedCreateInput = {
    id?: number
    employeeId: number
    year: number
    issued?: boolean
    issueDate?: Date | string | null
  }

  export type TravelTicketUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutTravelTicketsNestedInput
  }

  export type TravelTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TravelTicketCreateManyInput = {
    id?: number
    employeeId: number
    year: number
    issued?: boolean
    issueDate?: Date | string | null
  }

  export type TravelTicketUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TravelTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdvanceCreateInput = {
    amount: number
    date: Date | string
    status: string
    employee: EmployeeCreateNestedOneWithoutAdvancesInput
  }

  export type AdvanceUncheckedCreateInput = {
    id?: number
    employeeId: number
    amount: number
    date: Date | string
    status: string
  }

  export type AdvanceUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateOneRequiredWithoutAdvancesNestedInput
  }

  export type AdvanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AdvanceCreateManyInput = {
    id?: number
    employeeId: number
    amount: number
    date: Date | string
    status: string
  }

  export type AdvanceUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AdvanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AssetCreateInput = {
    assetType: string
    description?: string | null
    assignedDate: Date | string
    returned?: boolean
    returnDate?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: number
    employeeId: number
    assetType: string
    description?: string | null
    assignedDate: Date | string
    returned?: boolean
    returnDate?: Date | string | null
  }

  export type AssetUpdateInput = {
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetCreateManyInput = {
    id?: number
    employeeId: number
    assetType: string
    description?: string | null
    assignedDate: Date | string
    returned?: boolean
    returnDate?: Date | string | null
  }

  export type AssetUpdateManyMutationInput = {
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateInput = {
    date: Date | string
    checkIn?: Date | string | null
    checkOut?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    checkIn?: Date | string | null
    checkOut?: Date | string | null
  }

  export type AttendanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    checkIn?: Date | string | null
    checkOut?: Date | string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EntitlementCreateInput = {
    yearsWorked?: number | null
    fraction?: number | null
    terminationType?: string | null
    paid?: boolean
    paidDate?: Date | string | null
    type: string
    amount: number
    calculatedAt: Date | string
    employee: EmployeeCreateNestedOneWithoutEntitlementsInput
  }

  export type EntitlementUncheckedCreateInput = {
    id?: number
    yearsWorked?: number | null
    fraction?: number | null
    terminationType?: string | null
    paid?: boolean
    paidDate?: Date | string | null
    employeeId: number
    type: string
    amount: number
    calculatedAt: Date | string
  }

  export type EntitlementUpdateInput = {
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEntitlementsNestedInput
  }

  export type EntitlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementCreateManyInput = {
    id?: number
    yearsWorked?: number | null
    fraction?: number | null
    terminationType?: string | null
    paid?: boolean
    paidDate?: Date | string | null
    employeeId: number
    type: string
    amount: number
    calculatedAt: Date | string
  }

  export type EntitlementUpdateManyMutationInput = {
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    docType: string
    expiryDate: Date | string
    number?: string | null
    employee: EmployeeCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: number
    employeeId: number
    docType: string
    expiryDate: Date | string
    number?: string | null
  }

  export type DocumentUpdateInput = {
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: number
    employeeId: number
    docType: string
    expiryDate: Date | string
    number?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    userId: number
    action: string
    entityType: string
    entityId: number
    before?: string | null
    after?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userId: number
    action: string
    entityType: string
    entityId: number
    before?: string | null
    after?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userId: number
    action: string
    entityType: string
    entityId: number
    before?: string | null
    after?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    before?: NullableStringFieldUpdateOperationsInput | string | null
    after?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollRunCreateInput = {
    periodStart: Date | string
    periodEnd: Date | string
    status: string
    createdBy: number
    createdAt?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    totalGross?: number | null
    totalNet?: number | null
    totalDeductions?: number | null
    items?: PayrollItemCreateNestedManyWithoutPayrollRunInput
  }

  export type PayrollRunUncheckedCreateInput = {
    id?: number
    periodStart: Date | string
    periodEnd: Date | string
    status: string
    createdBy: number
    createdAt?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    totalGross?: number | null
    totalNet?: number | null
    totalDeductions?: number | null
    items?: PayrollItemUncheckedCreateNestedManyWithoutPayrollRunInput
  }

  export type PayrollRunUpdateInput = {
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalGross?: NullableFloatFieldUpdateOperationsInput | number | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: PayrollItemUpdateManyWithoutPayrollRunNestedInput
  }

  export type PayrollRunUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalGross?: NullableFloatFieldUpdateOperationsInput | number | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    items?: PayrollItemUncheckedUpdateManyWithoutPayrollRunNestedInput
  }

  export type PayrollRunCreateManyInput = {
    id?: number
    periodStart: Date | string
    periodEnd: Date | string
    status: string
    createdBy: number
    createdAt?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    totalGross?: number | null
    totalNet?: number | null
    totalDeductions?: number | null
  }

  export type PayrollRunUpdateManyMutationInput = {
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalGross?: NullableFloatFieldUpdateOperationsInput | number | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayrollRunUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalGross?: NullableFloatFieldUpdateOperationsInput | number | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayrollItemCreateInput = {
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
    payrollRun: PayrollRunCreateNestedOneWithoutItemsInput
    employee: EmployeeCreateNestedOneWithoutPayrollItemsInput
  }

  export type PayrollItemUncheckedCreateInput = {
    id?: number
    payrollRunId: number
    employeeId: number
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
  }

  export type PayrollItemUpdateInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payrollRun?: PayrollRunUpdateOneRequiredWithoutItemsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollItemsNestedInput
  }

  export type PayrollItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    payrollRunId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayrollItemCreateManyInput = {
    id?: number
    payrollRunId: number
    employeeId: number
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
  }

  export type PayrollItemUpdateManyMutationInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayrollItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    payrollRunId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalSettlementCreateInput = {
    terminationDate: Date | string
    terminationType: string
    lastWorkingDay: Date | string
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues?: number | null
    totalSettlement: number
    status: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    paidDate?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutFinalSettlementsInput
  }

  export type FinalSettlementUncheckedCreateInput = {
    id?: number
    employeeId: number
    terminationDate: Date | string
    terminationType: string
    lastWorkingDay: Date | string
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues?: number | null
    totalSettlement: number
    status: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    paidDate?: Date | string | null
  }

  export type FinalSettlementUpdateInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutFinalSettlementsNestedInput
  }

  export type FinalSettlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinalSettlementCreateManyInput = {
    id?: number
    employeeId: number
    terminationDate: Date | string
    terminationType: string
    lastWorkingDay: Date | string
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues?: number | null
    totalSettlement: number
    status: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    paidDate?: Date | string | null
  }

  export type FinalSettlementUpdateManyMutationInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinalSettlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EmployeeNullableRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    employeeId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type TravelTicketListRelationFilter = {
    every?: TravelTicketWhereInput
    some?: TravelTicketWhereInput
    none?: TravelTicketWhereInput
  }

  export type AdvanceListRelationFilter = {
    every?: AdvanceWhereInput
    some?: AdvanceWhereInput
    none?: AdvanceWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type EntitlementListRelationFilter = {
    every?: EntitlementWhereInput
    some?: EntitlementWhereInput
    none?: EntitlementWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PayrollItemListRelationFilter = {
    every?: PayrollItemWhereInput
    some?: PayrollItemWhereInput
    none?: PayrollItemWhereInput
  }

  export type FinalSettlementListRelationFilter = {
    every?: FinalSettlementWhereInput
    some?: FinalSettlementWhereInput
    none?: FinalSettlementWhereInput
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TravelTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntitlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinalSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    name?: SortOrder
    nameEn?: SortOrder
    nationalId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    iqamaNumber?: SortOrder
    iqamaExpiry?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    nationality?: SortOrder
    bankName?: SortOrder
    iban?: SortOrder
    workPermitNumber?: SortOrder
    workPermitExpiry?: SortOrder
    medicalInsuranceExpiry?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    name?: SortOrder
    nameEn?: SortOrder
    nationalId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    iqamaNumber?: SortOrder
    iqamaExpiry?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    nationality?: SortOrder
    bankName?: SortOrder
    iban?: SortOrder
    workPermitNumber?: SortOrder
    workPermitExpiry?: SortOrder
    medicalInsuranceExpiry?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    name?: SortOrder
    nameEn?: SortOrder
    nationalId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    iqamaNumber?: SortOrder
    iqamaExpiry?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    nationality?: SortOrder
    bankName?: SortOrder
    iban?: SortOrder
    workPermitNumber?: SortOrder
    workPermitExpiry?: SortOrder
    medicalInsuranceExpiry?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    contractType?: SortOrder
    probationDays?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    probationDays?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    contractType?: SortOrder
    probationDays?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    contractType?: SortOrder
    probationDays?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salary?: SortOrder
    leaveDays?: SortOrder
    leaveMoney?: SortOrder
    probationDays?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    daysCount?: SortOrder
    paid?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    sickPayRate?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    daysCount?: SortOrder
    paidAmount?: SortOrder
    approvedBy?: SortOrder
    sickPayRate?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    daysCount?: SortOrder
    paid?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    sickPayRate?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    daysCount?: SortOrder
    paid?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedReason?: SortOrder
    sickPayRate?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    daysCount?: SortOrder
    paidAmount?: SortOrder
    approvedBy?: SortOrder
    sickPayRate?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TravelTicketCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    issued?: SortOrder
    issueDate?: SortOrder
  }

  export type TravelTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
  }

  export type TravelTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    issued?: SortOrder
    issueDate?: SortOrder
  }

  export type TravelTicketMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    issued?: SortOrder
    issueDate?: SortOrder
  }

  export type TravelTicketSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
  }

  export type AdvanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type AdvanceAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
  }

  export type AdvanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type AdvanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type AdvanceSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assetType?: SortOrder
    description?: SortOrder
    assignedDate?: SortOrder
    returned?: SortOrder
    returnDate?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assetType?: SortOrder
    description?: SortOrder
    assignedDate?: SortOrder
    returned?: SortOrder
    returnDate?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    assetType?: SortOrder
    description?: SortOrder
    assignedDate?: SortOrder
    returned?: SortOrder
    returnDate?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type EntitlementCountOrderByAggregateInput = {
    id?: SortOrder
    yearsWorked?: SortOrder
    fraction?: SortOrder
    terminationType?: SortOrder
    paid?: SortOrder
    paidDate?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    calculatedAt?: SortOrder
  }

  export type EntitlementAvgOrderByAggregateInput = {
    id?: SortOrder
    yearsWorked?: SortOrder
    fraction?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
  }

  export type EntitlementMaxOrderByAggregateInput = {
    id?: SortOrder
    yearsWorked?: SortOrder
    fraction?: SortOrder
    terminationType?: SortOrder
    paid?: SortOrder
    paidDate?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    calculatedAt?: SortOrder
  }

  export type EntitlementMinOrderByAggregateInput = {
    id?: SortOrder
    yearsWorked?: SortOrder
    fraction?: SortOrder
    terminationType?: SortOrder
    paid?: SortOrder
    paidDate?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    calculatedAt?: SortOrder
  }

  export type EntitlementSumOrderByAggregateInput = {
    id?: SortOrder
    yearsWorked?: SortOrder
    fraction?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    docType?: SortOrder
    expiryDate?: SortOrder
    number?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    docType?: SortOrder
    expiryDate?: SortOrder
    number?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    docType?: SortOrder
    expiryDate?: SortOrder
    number?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type PayrollRunCountOrderByAggregateInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    lockedAt?: SortOrder
    totalGross?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
  }

  export type PayrollRunAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    totalGross?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
  }

  export type PayrollRunMaxOrderByAggregateInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    lockedAt?: SortOrder
    totalGross?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
  }

  export type PayrollRunMinOrderByAggregateInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    lockedAt?: SortOrder
    totalGross?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
  }

  export type PayrollRunSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    totalGross?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
  }

  export type PayrollRunRelationFilter = {
    is?: PayrollRunWhereInput
    isNot?: PayrollRunWhereInput
  }

  export type PayrollItemCountOrderByAggregateInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
    otherAllow?: SortOrder
    overtimePay?: SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrder
    loanDeduction?: SortOrder
    unpaidLeaveDeduction?: SortOrder
    otherDeductions?: SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
    iban?: SortOrder
    wpsStatus?: SortOrder
  }

  export type PayrollItemAvgOrderByAggregateInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
    otherAllow?: SortOrder
    overtimePay?: SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrder
    loanDeduction?: SortOrder
    unpaidLeaveDeduction?: SortOrder
    otherDeductions?: SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
  }

  export type PayrollItemMaxOrderByAggregateInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
    otherAllow?: SortOrder
    overtimePay?: SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrder
    loanDeduction?: SortOrder
    unpaidLeaveDeduction?: SortOrder
    otherDeductions?: SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
    iban?: SortOrder
    wpsStatus?: SortOrder
  }

  export type PayrollItemMinOrderByAggregateInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
    otherAllow?: SortOrder
    overtimePay?: SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrder
    loanDeduction?: SortOrder
    unpaidLeaveDeduction?: SortOrder
    otherDeductions?: SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
    iban?: SortOrder
    wpsStatus?: SortOrder
  }

  export type PayrollItemSumOrderByAggregateInput = {
    id?: SortOrder
    payrollRunId?: SortOrder
    employeeId?: SortOrder
    basicSalary?: SortOrder
    housingAllow?: SortOrder
    transportAllow?: SortOrder
    otherAllow?: SortOrder
    overtimePay?: SortOrder
    grossPay?: SortOrder
    advanceDeduction?: SortOrder
    loanDeduction?: SortOrder
    unpaidLeaveDeduction?: SortOrder
    otherDeductions?: SortOrder
    totalDeductions?: SortOrder
    netPay?: SortOrder
  }

  export type FinalSettlementCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    terminationType?: SortOrder
    lastWorkingDay?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrder
    totalSettlement?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    paidDate?: SortOrder
  }

  export type FinalSettlementAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrder
    totalSettlement?: SortOrder
    approvedBy?: SortOrder
  }

  export type FinalSettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    terminationType?: SortOrder
    lastWorkingDay?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrder
    totalSettlement?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    paidDate?: SortOrder
  }

  export type FinalSettlementMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    terminationType?: SortOrder
    lastWorkingDay?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrder
    totalSettlement?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    paidDate?: SortOrder
  }

  export type FinalSettlementSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    yearsWorked?: SortOrder
    eosbAmount?: SortOrder
    unusedLeaveDays?: SortOrder
    unusedLeavePay?: SortOrder
    otherDues?: SortOrder
    totalSettlement?: SortOrder
    approvedBy?: SortOrder
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContractCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type TravelTicketCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TravelTicketCreateWithoutEmployeeInput, TravelTicketUncheckedCreateWithoutEmployeeInput> | TravelTicketCreateWithoutEmployeeInput[] | TravelTicketUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TravelTicketCreateOrConnectWithoutEmployeeInput | TravelTicketCreateOrConnectWithoutEmployeeInput[]
    createMany?: TravelTicketCreateManyEmployeeInputEnvelope
    connect?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
  }

  export type AdvanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AdvanceCreateWithoutEmployeeInput, AdvanceUncheckedCreateWithoutEmployeeInput> | AdvanceCreateWithoutEmployeeInput[] | AdvanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AdvanceCreateOrConnectWithoutEmployeeInput | AdvanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AdvanceCreateManyEmployeeInputEnvelope
    connect?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AssetCreateWithoutEmployeeInput, AssetUncheckedCreateWithoutEmployeeInput> | AssetCreateWithoutEmployeeInput[] | AssetUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutEmployeeInput | AssetCreateOrConnectWithoutEmployeeInput[]
    createMany?: AssetCreateManyEmployeeInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EntitlementCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EntitlementCreateWithoutEmployeeInput, EntitlementUncheckedCreateWithoutEmployeeInput> | EntitlementCreateWithoutEmployeeInput[] | EntitlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutEmployeeInput | EntitlementCreateOrConnectWithoutEmployeeInput[]
    createMany?: EntitlementCreateManyEmployeeInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type PayrollItemCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollItemCreateWithoutEmployeeInput, PayrollItemUncheckedCreateWithoutEmployeeInput> | PayrollItemCreateWithoutEmployeeInput[] | PayrollItemUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutEmployeeInput | PayrollItemCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollItemCreateManyEmployeeInputEnvelope
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
  }

  export type FinalSettlementCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<FinalSettlementCreateWithoutEmployeeInput, FinalSettlementUncheckedCreateWithoutEmployeeInput> | FinalSettlementCreateWithoutEmployeeInput[] | FinalSettlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FinalSettlementCreateOrConnectWithoutEmployeeInput | FinalSettlementCreateOrConnectWithoutEmployeeInput[]
    createMany?: FinalSettlementCreateManyEmployeeInputEnvelope
    connect?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TravelTicketCreateWithoutEmployeeInput, TravelTicketUncheckedCreateWithoutEmployeeInput> | TravelTicketCreateWithoutEmployeeInput[] | TravelTicketUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TravelTicketCreateOrConnectWithoutEmployeeInput | TravelTicketCreateOrConnectWithoutEmployeeInput[]
    createMany?: TravelTicketCreateManyEmployeeInputEnvelope
    connect?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
  }

  export type AdvanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AdvanceCreateWithoutEmployeeInput, AdvanceUncheckedCreateWithoutEmployeeInput> | AdvanceCreateWithoutEmployeeInput[] | AdvanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AdvanceCreateOrConnectWithoutEmployeeInput | AdvanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AdvanceCreateManyEmployeeInputEnvelope
    connect?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AssetCreateWithoutEmployeeInput, AssetUncheckedCreateWithoutEmployeeInput> | AssetCreateWithoutEmployeeInput[] | AssetUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutEmployeeInput | AssetCreateOrConnectWithoutEmployeeInput[]
    createMany?: AssetCreateManyEmployeeInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EntitlementUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EntitlementCreateWithoutEmployeeInput, EntitlementUncheckedCreateWithoutEmployeeInput> | EntitlementCreateWithoutEmployeeInput[] | EntitlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutEmployeeInput | EntitlementCreateOrConnectWithoutEmployeeInput[]
    createMany?: EntitlementCreateManyEmployeeInputEnvelope
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollItemCreateWithoutEmployeeInput, PayrollItemUncheckedCreateWithoutEmployeeInput> | PayrollItemCreateWithoutEmployeeInput[] | PayrollItemUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutEmployeeInput | PayrollItemCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollItemCreateManyEmployeeInputEnvelope
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
  }

  export type FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<FinalSettlementCreateWithoutEmployeeInput, FinalSettlementUncheckedCreateWithoutEmployeeInput> | FinalSettlementCreateWithoutEmployeeInput[] | FinalSettlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FinalSettlementCreateOrConnectWithoutEmployeeInput | FinalSettlementCreateOrConnectWithoutEmployeeInput[]
    createMany?: FinalSettlementCreateManyEmployeeInputEnvelope
    connect?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ContractUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type TravelTicketUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TravelTicketCreateWithoutEmployeeInput, TravelTicketUncheckedCreateWithoutEmployeeInput> | TravelTicketCreateWithoutEmployeeInput[] | TravelTicketUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TravelTicketCreateOrConnectWithoutEmployeeInput | TravelTicketCreateOrConnectWithoutEmployeeInput[]
    upsert?: TravelTicketUpsertWithWhereUniqueWithoutEmployeeInput | TravelTicketUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TravelTicketCreateManyEmployeeInputEnvelope
    set?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    disconnect?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    delete?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    connect?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    update?: TravelTicketUpdateWithWhereUniqueWithoutEmployeeInput | TravelTicketUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TravelTicketUpdateManyWithWhereWithoutEmployeeInput | TravelTicketUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TravelTicketScalarWhereInput | TravelTicketScalarWhereInput[]
  }

  export type AdvanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AdvanceCreateWithoutEmployeeInput, AdvanceUncheckedCreateWithoutEmployeeInput> | AdvanceCreateWithoutEmployeeInput[] | AdvanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AdvanceCreateOrConnectWithoutEmployeeInput | AdvanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AdvanceUpsertWithWhereUniqueWithoutEmployeeInput | AdvanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AdvanceCreateManyEmployeeInputEnvelope
    set?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    disconnect?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    delete?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    connect?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    update?: AdvanceUpdateWithWhereUniqueWithoutEmployeeInput | AdvanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AdvanceUpdateManyWithWhereWithoutEmployeeInput | AdvanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AdvanceScalarWhereInput | AdvanceScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AssetCreateWithoutEmployeeInput, AssetUncheckedCreateWithoutEmployeeInput> | AssetCreateWithoutEmployeeInput[] | AssetUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutEmployeeInput | AssetCreateOrConnectWithoutEmployeeInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutEmployeeInput | AssetUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AssetCreateManyEmployeeInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutEmployeeInput | AssetUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutEmployeeInput | AssetUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EntitlementUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EntitlementCreateWithoutEmployeeInput, EntitlementUncheckedCreateWithoutEmployeeInput> | EntitlementCreateWithoutEmployeeInput[] | EntitlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutEmployeeInput | EntitlementCreateOrConnectWithoutEmployeeInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutEmployeeInput | EntitlementUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EntitlementCreateManyEmployeeInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutEmployeeInput | EntitlementUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutEmployeeInput | EntitlementUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEmployeeInput | DocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEmployeeInput | DocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEmployeeInput | DocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollItemUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollItemCreateWithoutEmployeeInput, PayrollItemUncheckedCreateWithoutEmployeeInput> | PayrollItemCreateWithoutEmployeeInput[] | PayrollItemUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutEmployeeInput | PayrollItemCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollItemUpsertWithWhereUniqueWithoutEmployeeInput | PayrollItemUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollItemCreateManyEmployeeInputEnvelope
    set?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    disconnect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    delete?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    update?: PayrollItemUpdateWithWhereUniqueWithoutEmployeeInput | PayrollItemUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollItemUpdateManyWithWhereWithoutEmployeeInput | PayrollItemUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollItemScalarWhereInput | PayrollItemScalarWhereInput[]
  }

  export type FinalSettlementUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<FinalSettlementCreateWithoutEmployeeInput, FinalSettlementUncheckedCreateWithoutEmployeeInput> | FinalSettlementCreateWithoutEmployeeInput[] | FinalSettlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FinalSettlementCreateOrConnectWithoutEmployeeInput | FinalSettlementCreateOrConnectWithoutEmployeeInput[]
    upsert?: FinalSettlementUpsertWithWhereUniqueWithoutEmployeeInput | FinalSettlementUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: FinalSettlementCreateManyEmployeeInputEnvelope
    set?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    disconnect?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    delete?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    connect?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    update?: FinalSettlementUpdateWithWhereUniqueWithoutEmployeeInput | FinalSettlementUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: FinalSettlementUpdateManyWithWhereWithoutEmployeeInput | FinalSettlementUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: FinalSettlementScalarWhereInput | FinalSettlementScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TravelTicketCreateWithoutEmployeeInput, TravelTicketUncheckedCreateWithoutEmployeeInput> | TravelTicketCreateWithoutEmployeeInput[] | TravelTicketUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TravelTicketCreateOrConnectWithoutEmployeeInput | TravelTicketCreateOrConnectWithoutEmployeeInput[]
    upsert?: TravelTicketUpsertWithWhereUniqueWithoutEmployeeInput | TravelTicketUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TravelTicketCreateManyEmployeeInputEnvelope
    set?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    disconnect?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    delete?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    connect?: TravelTicketWhereUniqueInput | TravelTicketWhereUniqueInput[]
    update?: TravelTicketUpdateWithWhereUniqueWithoutEmployeeInput | TravelTicketUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TravelTicketUpdateManyWithWhereWithoutEmployeeInput | TravelTicketUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TravelTicketScalarWhereInput | TravelTicketScalarWhereInput[]
  }

  export type AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AdvanceCreateWithoutEmployeeInput, AdvanceUncheckedCreateWithoutEmployeeInput> | AdvanceCreateWithoutEmployeeInput[] | AdvanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AdvanceCreateOrConnectWithoutEmployeeInput | AdvanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AdvanceUpsertWithWhereUniqueWithoutEmployeeInput | AdvanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AdvanceCreateManyEmployeeInputEnvelope
    set?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    disconnect?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    delete?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    connect?: AdvanceWhereUniqueInput | AdvanceWhereUniqueInput[]
    update?: AdvanceUpdateWithWhereUniqueWithoutEmployeeInput | AdvanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AdvanceUpdateManyWithWhereWithoutEmployeeInput | AdvanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AdvanceScalarWhereInput | AdvanceScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AssetCreateWithoutEmployeeInput, AssetUncheckedCreateWithoutEmployeeInput> | AssetCreateWithoutEmployeeInput[] | AssetUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutEmployeeInput | AssetCreateOrConnectWithoutEmployeeInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutEmployeeInput | AssetUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AssetCreateManyEmployeeInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutEmployeeInput | AssetUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutEmployeeInput | AssetUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EntitlementCreateWithoutEmployeeInput, EntitlementUncheckedCreateWithoutEmployeeInput> | EntitlementCreateWithoutEmployeeInput[] | EntitlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EntitlementCreateOrConnectWithoutEmployeeInput | EntitlementCreateOrConnectWithoutEmployeeInput[]
    upsert?: EntitlementUpsertWithWhereUniqueWithoutEmployeeInput | EntitlementUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EntitlementCreateManyEmployeeInputEnvelope
    set?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    disconnect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    delete?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    connect?: EntitlementWhereUniqueInput | EntitlementWhereUniqueInput[]
    update?: EntitlementUpdateWithWhereUniqueWithoutEmployeeInput | EntitlementUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EntitlementUpdateManyWithWhereWithoutEmployeeInput | EntitlementUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput> | DocumentCreateWithoutEmployeeInput[] | DocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmployeeInput | DocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEmployeeInput | DocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DocumentCreateManyEmployeeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEmployeeInput | DocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEmployeeInput | DocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollItemCreateWithoutEmployeeInput, PayrollItemUncheckedCreateWithoutEmployeeInput> | PayrollItemCreateWithoutEmployeeInput[] | PayrollItemUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutEmployeeInput | PayrollItemCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollItemUpsertWithWhereUniqueWithoutEmployeeInput | PayrollItemUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollItemCreateManyEmployeeInputEnvelope
    set?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    disconnect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    delete?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    update?: PayrollItemUpdateWithWhereUniqueWithoutEmployeeInput | PayrollItemUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollItemUpdateManyWithWhereWithoutEmployeeInput | PayrollItemUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollItemScalarWhereInput | PayrollItemScalarWhereInput[]
  }

  export type FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<FinalSettlementCreateWithoutEmployeeInput, FinalSettlementUncheckedCreateWithoutEmployeeInput> | FinalSettlementCreateWithoutEmployeeInput[] | FinalSettlementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FinalSettlementCreateOrConnectWithoutEmployeeInput | FinalSettlementCreateOrConnectWithoutEmployeeInput[]
    upsert?: FinalSettlementUpsertWithWhereUniqueWithoutEmployeeInput | FinalSettlementUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: FinalSettlementCreateManyEmployeeInputEnvelope
    set?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    disconnect?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    delete?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    connect?: FinalSettlementWhereUniqueInput | FinalSettlementWhereUniqueInput[]
    update?: FinalSettlementUpdateWithWhereUniqueWithoutEmployeeInput | FinalSettlementUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: FinalSettlementUpdateManyWithWhereWithoutEmployeeInput | FinalSettlementUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: FinalSettlementScalarWhereInput | FinalSettlementScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutContractsInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    upsert?: EmployeeUpsertWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutContractsInput, EmployeeUpdateWithoutContractsInput>, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeCreateNestedOneWithoutTravelTicketsInput = {
    create?: XOR<EmployeeCreateWithoutTravelTicketsInput, EmployeeUncheckedCreateWithoutTravelTicketsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTravelTicketsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutTravelTicketsNestedInput = {
    create?: XOR<EmployeeCreateWithoutTravelTicketsInput, EmployeeUncheckedCreateWithoutTravelTicketsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTravelTicketsInput
    upsert?: EmployeeUpsertWithoutTravelTicketsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTravelTicketsInput, EmployeeUpdateWithoutTravelTicketsInput>, EmployeeUncheckedUpdateWithoutTravelTicketsInput>
  }

  export type EmployeeCreateNestedOneWithoutAdvancesInput = {
    create?: XOR<EmployeeCreateWithoutAdvancesInput, EmployeeUncheckedCreateWithoutAdvancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAdvancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAdvancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAdvancesInput, EmployeeUncheckedCreateWithoutAdvancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAdvancesInput
    upsert?: EmployeeUpsertWithoutAdvancesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAdvancesInput, EmployeeUpdateWithoutAdvancesInput>, EmployeeUncheckedUpdateWithoutAdvancesInput>
  }

  export type EmployeeCreateNestedOneWithoutAssetsInput = {
    create?: XOR<EmployeeCreateWithoutAssetsInput, EmployeeUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssetsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAssetsInput, EmployeeUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssetsInput
    upsert?: EmployeeUpsertWithoutAssetsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAssetsInput, EmployeeUpdateWithoutAssetsInput>, EmployeeUncheckedUpdateWithoutAssetsInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendancesInput
    upsert?: EmployeeUpsertWithoutAttendancesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendancesInput, EmployeeUpdateWithoutAttendancesInput>, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeeCreateNestedOneWithoutEntitlementsInput = {
    create?: XOR<EmployeeCreateWithoutEntitlementsInput, EmployeeUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEntitlementsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEntitlementsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEntitlementsInput, EmployeeUncheckedCreateWithoutEntitlementsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEntitlementsInput
    upsert?: EmployeeUpsertWithoutEntitlementsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEntitlementsInput, EmployeeUpdateWithoutEntitlementsInput>, EmployeeUncheckedUpdateWithoutEntitlementsInput>
  }

  export type EmployeeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    upsert?: EmployeeUpsertWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDocumentsInput, EmployeeUpdateWithoutDocumentsInput>, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type PayrollItemCreateNestedManyWithoutPayrollRunInput = {
    create?: XOR<PayrollItemCreateWithoutPayrollRunInput, PayrollItemUncheckedCreateWithoutPayrollRunInput> | PayrollItemCreateWithoutPayrollRunInput[] | PayrollItemUncheckedCreateWithoutPayrollRunInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutPayrollRunInput | PayrollItemCreateOrConnectWithoutPayrollRunInput[]
    createMany?: PayrollItemCreateManyPayrollRunInputEnvelope
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
  }

  export type PayrollItemUncheckedCreateNestedManyWithoutPayrollRunInput = {
    create?: XOR<PayrollItemCreateWithoutPayrollRunInput, PayrollItemUncheckedCreateWithoutPayrollRunInput> | PayrollItemCreateWithoutPayrollRunInput[] | PayrollItemUncheckedCreateWithoutPayrollRunInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutPayrollRunInput | PayrollItemCreateOrConnectWithoutPayrollRunInput[]
    createMany?: PayrollItemCreateManyPayrollRunInputEnvelope
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
  }

  export type PayrollItemUpdateManyWithoutPayrollRunNestedInput = {
    create?: XOR<PayrollItemCreateWithoutPayrollRunInput, PayrollItemUncheckedCreateWithoutPayrollRunInput> | PayrollItemCreateWithoutPayrollRunInput[] | PayrollItemUncheckedCreateWithoutPayrollRunInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutPayrollRunInput | PayrollItemCreateOrConnectWithoutPayrollRunInput[]
    upsert?: PayrollItemUpsertWithWhereUniqueWithoutPayrollRunInput | PayrollItemUpsertWithWhereUniqueWithoutPayrollRunInput[]
    createMany?: PayrollItemCreateManyPayrollRunInputEnvelope
    set?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    disconnect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    delete?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    update?: PayrollItemUpdateWithWhereUniqueWithoutPayrollRunInput | PayrollItemUpdateWithWhereUniqueWithoutPayrollRunInput[]
    updateMany?: PayrollItemUpdateManyWithWhereWithoutPayrollRunInput | PayrollItemUpdateManyWithWhereWithoutPayrollRunInput[]
    deleteMany?: PayrollItemScalarWhereInput | PayrollItemScalarWhereInput[]
  }

  export type PayrollItemUncheckedUpdateManyWithoutPayrollRunNestedInput = {
    create?: XOR<PayrollItemCreateWithoutPayrollRunInput, PayrollItemUncheckedCreateWithoutPayrollRunInput> | PayrollItemCreateWithoutPayrollRunInput[] | PayrollItemUncheckedCreateWithoutPayrollRunInput[]
    connectOrCreate?: PayrollItemCreateOrConnectWithoutPayrollRunInput | PayrollItemCreateOrConnectWithoutPayrollRunInput[]
    upsert?: PayrollItemUpsertWithWhereUniqueWithoutPayrollRunInput | PayrollItemUpsertWithWhereUniqueWithoutPayrollRunInput[]
    createMany?: PayrollItemCreateManyPayrollRunInputEnvelope
    set?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    disconnect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    delete?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    connect?: PayrollItemWhereUniqueInput | PayrollItemWhereUniqueInput[]
    update?: PayrollItemUpdateWithWhereUniqueWithoutPayrollRunInput | PayrollItemUpdateWithWhereUniqueWithoutPayrollRunInput[]
    updateMany?: PayrollItemUpdateManyWithWhereWithoutPayrollRunInput | PayrollItemUpdateManyWithWhereWithoutPayrollRunInput[]
    deleteMany?: PayrollItemScalarWhereInput | PayrollItemScalarWhereInput[]
  }

  export type PayrollRunCreateNestedOneWithoutItemsInput = {
    create?: XOR<PayrollRunCreateWithoutItemsInput, PayrollRunUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PayrollRunCreateOrConnectWithoutItemsInput
    connect?: PayrollRunWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPayrollItemsInput = {
    create?: XOR<EmployeeCreateWithoutPayrollItemsInput, EmployeeUncheckedCreateWithoutPayrollItemsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollItemsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PayrollRunUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PayrollRunCreateWithoutItemsInput, PayrollRunUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PayrollRunCreateOrConnectWithoutItemsInput
    upsert?: PayrollRunUpsertWithoutItemsInput
    connect?: PayrollRunWhereUniqueInput
    update?: XOR<XOR<PayrollRunUpdateToOneWithWhereWithoutItemsInput, PayrollRunUpdateWithoutItemsInput>, PayrollRunUncheckedUpdateWithoutItemsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutPayrollItemsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayrollItemsInput, EmployeeUncheckedCreateWithoutPayrollItemsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollItemsInput
    upsert?: EmployeeUpsertWithoutPayrollItemsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayrollItemsInput, EmployeeUpdateWithoutPayrollItemsInput>, EmployeeUncheckedUpdateWithoutPayrollItemsInput>
  }

  export type EmployeeCreateNestedOneWithoutFinalSettlementsInput = {
    create?: XOR<EmployeeCreateWithoutFinalSettlementsInput, EmployeeUncheckedCreateWithoutFinalSettlementsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFinalSettlementsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutFinalSettlementsNestedInput = {
    create?: XOR<EmployeeCreateWithoutFinalSettlementsInput, EmployeeUncheckedCreateWithoutFinalSettlementsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFinalSettlementsInput
    upsert?: EmployeeUpsertWithoutFinalSettlementsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutFinalSettlementsInput, EmployeeUpdateWithoutFinalSettlementsInput>, EmployeeUncheckedUpdateWithoutFinalSettlementsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmployeeCreateWithoutUserInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ContractCreateWithoutEmployeeInput = {
    startDate: Date | string
    endDate?: Date | string | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays?: number | null
    basicSalary?: number | null
    housingAllow?: number | null
    transportAllow?: number | null
  }

  export type ContractUncheckedCreateWithoutEmployeeInput = {
    id?: number
    startDate: Date | string
    endDate?: Date | string | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays?: number | null
    basicSalary?: number | null
    housingAllow?: number | null
    transportAllow?: number | null
  }

  export type ContractCreateOrConnectWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateManyEmployeeInputEnvelope = {
    data: ContractCreateManyEmployeeInput | ContractCreateManyEmployeeInput[]
  }

  export type LeaveCreateWithoutEmployeeInput = {
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    daysCount: number
    paid: boolean
    paidAmount?: number | null
    status: string
    requestDate?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    sickPayRate?: number | null
  }

  export type LeaveUncheckedCreateWithoutEmployeeInput = {
    id?: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    daysCount: number
    paid: boolean
    paidAmount?: number | null
    status: string
    requestDate?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    sickPayRate?: number | null
  }

  export type LeaveCreateOrConnectWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveCreateManyEmployeeInputEnvelope = {
    data: LeaveCreateManyEmployeeInput | LeaveCreateManyEmployeeInput[]
  }

  export type TravelTicketCreateWithoutEmployeeInput = {
    year: number
    issued?: boolean
    issueDate?: Date | string | null
  }

  export type TravelTicketUncheckedCreateWithoutEmployeeInput = {
    id?: number
    year: number
    issued?: boolean
    issueDate?: Date | string | null
  }

  export type TravelTicketCreateOrConnectWithoutEmployeeInput = {
    where: TravelTicketWhereUniqueInput
    create: XOR<TravelTicketCreateWithoutEmployeeInput, TravelTicketUncheckedCreateWithoutEmployeeInput>
  }

  export type TravelTicketCreateManyEmployeeInputEnvelope = {
    data: TravelTicketCreateManyEmployeeInput | TravelTicketCreateManyEmployeeInput[]
  }

  export type AdvanceCreateWithoutEmployeeInput = {
    amount: number
    date: Date | string
    status: string
  }

  export type AdvanceUncheckedCreateWithoutEmployeeInput = {
    id?: number
    amount: number
    date: Date | string
    status: string
  }

  export type AdvanceCreateOrConnectWithoutEmployeeInput = {
    where: AdvanceWhereUniqueInput
    create: XOR<AdvanceCreateWithoutEmployeeInput, AdvanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AdvanceCreateManyEmployeeInputEnvelope = {
    data: AdvanceCreateManyEmployeeInput | AdvanceCreateManyEmployeeInput[]
  }

  export type AssetCreateWithoutEmployeeInput = {
    assetType: string
    description?: string | null
    assignedDate: Date | string
    returned?: boolean
    returnDate?: Date | string | null
  }

  export type AssetUncheckedCreateWithoutEmployeeInput = {
    id?: number
    assetType: string
    description?: string | null
    assignedDate: Date | string
    returned?: boolean
    returnDate?: Date | string | null
  }

  export type AssetCreateOrConnectWithoutEmployeeInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutEmployeeInput, AssetUncheckedCreateWithoutEmployeeInput>
  }

  export type AssetCreateManyEmployeeInputEnvelope = {
    data: AssetCreateManyEmployeeInput | AssetCreateManyEmployeeInput[]
  }

  export type AttendanceCreateWithoutEmployeeInput = {
    date: Date | string
    checkIn?: Date | string | null
    checkOut?: Date | string | null
  }

  export type AttendanceUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    checkIn?: Date | string | null
    checkOut?: Date | string | null
  }

  export type AttendanceCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceCreateManyEmployeeInputEnvelope = {
    data: AttendanceCreateManyEmployeeInput | AttendanceCreateManyEmployeeInput[]
  }

  export type EntitlementCreateWithoutEmployeeInput = {
    yearsWorked?: number | null
    fraction?: number | null
    terminationType?: string | null
    paid?: boolean
    paidDate?: Date | string | null
    type: string
    amount: number
    calculatedAt: Date | string
  }

  export type EntitlementUncheckedCreateWithoutEmployeeInput = {
    id?: number
    yearsWorked?: number | null
    fraction?: number | null
    terminationType?: string | null
    paid?: boolean
    paidDate?: Date | string | null
    type: string
    amount: number
    calculatedAt: Date | string
  }

  export type EntitlementCreateOrConnectWithoutEmployeeInput = {
    where: EntitlementWhereUniqueInput
    create: XOR<EntitlementCreateWithoutEmployeeInput, EntitlementUncheckedCreateWithoutEmployeeInput>
  }

  export type EntitlementCreateManyEmployeeInputEnvelope = {
    data: EntitlementCreateManyEmployeeInput | EntitlementCreateManyEmployeeInput[]
  }

  export type DocumentCreateWithoutEmployeeInput = {
    docType: string
    expiryDate: Date | string
    number?: string | null
  }

  export type DocumentUncheckedCreateWithoutEmployeeInput = {
    id?: number
    docType: string
    expiryDate: Date | string
    number?: string | null
  }

  export type DocumentCreateOrConnectWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type DocumentCreateManyEmployeeInputEnvelope = {
    data: DocumentCreateManyEmployeeInput | DocumentCreateManyEmployeeInput[]
  }

  export type UserCreateWithoutEmployeeInput = {
    username: string
    password: string
    role: string
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: number
    username: string
    password: string
    role: string
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollItemCreateWithoutEmployeeInput = {
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
    payrollRun: PayrollRunCreateNestedOneWithoutItemsInput
  }

  export type PayrollItemUncheckedCreateWithoutEmployeeInput = {
    id?: number
    payrollRunId: number
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
  }

  export type PayrollItemCreateOrConnectWithoutEmployeeInput = {
    where: PayrollItemWhereUniqueInput
    create: XOR<PayrollItemCreateWithoutEmployeeInput, PayrollItemUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollItemCreateManyEmployeeInputEnvelope = {
    data: PayrollItemCreateManyEmployeeInput | PayrollItemCreateManyEmployeeInput[]
  }

  export type FinalSettlementCreateWithoutEmployeeInput = {
    terminationDate: Date | string
    terminationType: string
    lastWorkingDay: Date | string
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues?: number | null
    totalSettlement: number
    status: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    paidDate?: Date | string | null
  }

  export type FinalSettlementUncheckedCreateWithoutEmployeeInput = {
    id?: number
    terminationDate: Date | string
    terminationType: string
    lastWorkingDay: Date | string
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues?: number | null
    totalSettlement: number
    status: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    paidDate?: Date | string | null
  }

  export type FinalSettlementCreateOrConnectWithoutEmployeeInput = {
    where: FinalSettlementWhereUniqueInput
    create: XOR<FinalSettlementCreateWithoutEmployeeInput, FinalSettlementUncheckedCreateWithoutEmployeeInput>
  }

  export type FinalSettlementCreateManyEmployeeInputEnvelope = {
    data: FinalSettlementCreateManyEmployeeInput | FinalSettlementCreateManyEmployeeInput[]
  }

  export type ContractUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithWhereWithoutEmployeeInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: IntFilter<"Contract"> | number
    employeeId?: IntFilter<"Contract"> | number
    startDate?: DateTimeFilter<"Contract"> | Date | string
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    salary?: FloatFilter<"Contract"> | number
    leaveDays?: IntFilter<"Contract"> | number
    leaveMoney?: FloatFilter<"Contract"> | number
    contractType?: StringFilter<"Contract"> | string
    probationDays?: IntNullableFilter<"Contract"> | number | null
    basicSalary?: FloatNullableFilter<"Contract"> | number | null
    housingAllow?: FloatNullableFilter<"Contract"> | number | null
    transportAllow?: FloatNullableFilter<"Contract"> | number | null
  }

  export type LeaveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: IntFilter<"Leave"> | number
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    daysCount?: IntFilter<"Leave"> | number
    paid?: BoolFilter<"Leave"> | boolean
    paidAmount?: FloatNullableFilter<"Leave"> | number | null
    status?: StringFilter<"Leave"> | string
    requestDate?: DateTimeFilter<"Leave"> | Date | string
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    approvedAt?: DateTimeNullableFilter<"Leave"> | Date | string | null
    rejectedReason?: StringNullableFilter<"Leave"> | string | null
    sickPayRate?: FloatNullableFilter<"Leave"> | number | null
  }

  export type TravelTicketUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TravelTicketWhereUniqueInput
    update: XOR<TravelTicketUpdateWithoutEmployeeInput, TravelTicketUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TravelTicketCreateWithoutEmployeeInput, TravelTicketUncheckedCreateWithoutEmployeeInput>
  }

  export type TravelTicketUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TravelTicketWhereUniqueInput
    data: XOR<TravelTicketUpdateWithoutEmployeeInput, TravelTicketUncheckedUpdateWithoutEmployeeInput>
  }

  export type TravelTicketUpdateManyWithWhereWithoutEmployeeInput = {
    where: TravelTicketScalarWhereInput
    data: XOR<TravelTicketUpdateManyMutationInput, TravelTicketUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TravelTicketScalarWhereInput = {
    AND?: TravelTicketScalarWhereInput | TravelTicketScalarWhereInput[]
    OR?: TravelTicketScalarWhereInput[]
    NOT?: TravelTicketScalarWhereInput | TravelTicketScalarWhereInput[]
    id?: IntFilter<"TravelTicket"> | number
    employeeId?: IntFilter<"TravelTicket"> | number
    year?: IntFilter<"TravelTicket"> | number
    issued?: BoolFilter<"TravelTicket"> | boolean
    issueDate?: DateTimeNullableFilter<"TravelTicket"> | Date | string | null
  }

  export type AdvanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AdvanceWhereUniqueInput
    update: XOR<AdvanceUpdateWithoutEmployeeInput, AdvanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AdvanceCreateWithoutEmployeeInput, AdvanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AdvanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AdvanceWhereUniqueInput
    data: XOR<AdvanceUpdateWithoutEmployeeInput, AdvanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AdvanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AdvanceScalarWhereInput
    data: XOR<AdvanceUpdateManyMutationInput, AdvanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AdvanceScalarWhereInput = {
    AND?: AdvanceScalarWhereInput | AdvanceScalarWhereInput[]
    OR?: AdvanceScalarWhereInput[]
    NOT?: AdvanceScalarWhereInput | AdvanceScalarWhereInput[]
    id?: IntFilter<"Advance"> | number
    employeeId?: IntFilter<"Advance"> | number
    amount?: FloatFilter<"Advance"> | number
    date?: DateTimeFilter<"Advance"> | Date | string
    status?: StringFilter<"Advance"> | string
  }

  export type AssetUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutEmployeeInput, AssetUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AssetCreateWithoutEmployeeInput, AssetUncheckedCreateWithoutEmployeeInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutEmployeeInput, AssetUncheckedUpdateWithoutEmployeeInput>
  }

  export type AssetUpdateManyWithWhereWithoutEmployeeInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: IntFilter<"Asset"> | number
    employeeId?: IntFilter<"Asset"> | number
    assetType?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    assignedDate?: DateTimeFilter<"Asset"> | Date | string
    returned?: BoolFilter<"Asset"> | boolean
    returnDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: IntFilter<"Attendance"> | number
    employeeId?: IntFilter<"Attendance"> | number
    date?: DateTimeFilter<"Attendance"> | Date | string
    checkIn?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    checkOut?: DateTimeNullableFilter<"Attendance"> | Date | string | null
  }

  export type EntitlementUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EntitlementWhereUniqueInput
    update: XOR<EntitlementUpdateWithoutEmployeeInput, EntitlementUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EntitlementCreateWithoutEmployeeInput, EntitlementUncheckedCreateWithoutEmployeeInput>
  }

  export type EntitlementUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EntitlementWhereUniqueInput
    data: XOR<EntitlementUpdateWithoutEmployeeInput, EntitlementUncheckedUpdateWithoutEmployeeInput>
  }

  export type EntitlementUpdateManyWithWhereWithoutEmployeeInput = {
    where: EntitlementScalarWhereInput
    data: XOR<EntitlementUpdateManyMutationInput, EntitlementUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EntitlementScalarWhereInput = {
    AND?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
    OR?: EntitlementScalarWhereInput[]
    NOT?: EntitlementScalarWhereInput | EntitlementScalarWhereInput[]
    id?: IntFilter<"Entitlement"> | number
    yearsWorked?: FloatNullableFilter<"Entitlement"> | number | null
    fraction?: FloatNullableFilter<"Entitlement"> | number | null
    terminationType?: StringNullableFilter<"Entitlement"> | string | null
    paid?: BoolFilter<"Entitlement"> | boolean
    paidDate?: DateTimeNullableFilter<"Entitlement"> | Date | string | null
    employeeId?: IntFilter<"Entitlement"> | number
    type?: StringFilter<"Entitlement"> | string
    amount?: FloatFilter<"Entitlement"> | number
    calculatedAt?: DateTimeFilter<"Entitlement"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutEmployeeInput, DocumentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DocumentCreateWithoutEmployeeInput, DocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutEmployeeInput, DocumentUncheckedUpdateWithoutEmployeeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutEmployeeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: IntFilter<"Document"> | number
    employeeId?: IntFilter<"Document"> | number
    docType?: StringFilter<"Document"> | string
    expiryDate?: DateTimeFilter<"Document"> | Date | string
    number?: StringNullableFilter<"Document"> | string | null
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type PayrollItemUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollItemWhereUniqueInput
    update: XOR<PayrollItemUpdateWithoutEmployeeInput, PayrollItemUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollItemCreateWithoutEmployeeInput, PayrollItemUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollItemUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollItemWhereUniqueInput
    data: XOR<PayrollItemUpdateWithoutEmployeeInput, PayrollItemUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollItemUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollItemScalarWhereInput
    data: XOR<PayrollItemUpdateManyMutationInput, PayrollItemUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollItemScalarWhereInput = {
    AND?: PayrollItemScalarWhereInput | PayrollItemScalarWhereInput[]
    OR?: PayrollItemScalarWhereInput[]
    NOT?: PayrollItemScalarWhereInput | PayrollItemScalarWhereInput[]
    id?: IntFilter<"PayrollItem"> | number
    payrollRunId?: IntFilter<"PayrollItem"> | number
    employeeId?: IntFilter<"PayrollItem"> | number
    basicSalary?: FloatFilter<"PayrollItem"> | number
    housingAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    transportAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    otherAllow?: FloatNullableFilter<"PayrollItem"> | number | null
    overtimePay?: FloatNullableFilter<"PayrollItem"> | number | null
    grossPay?: FloatFilter<"PayrollItem"> | number
    advanceDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    loanDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    unpaidLeaveDeduction?: FloatNullableFilter<"PayrollItem"> | number | null
    otherDeductions?: FloatNullableFilter<"PayrollItem"> | number | null
    totalDeductions?: FloatFilter<"PayrollItem"> | number
    netPay?: FloatFilter<"PayrollItem"> | number
    iban?: StringNullableFilter<"PayrollItem"> | string | null
    wpsStatus?: StringNullableFilter<"PayrollItem"> | string | null
  }

  export type FinalSettlementUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: FinalSettlementWhereUniqueInput
    update: XOR<FinalSettlementUpdateWithoutEmployeeInput, FinalSettlementUncheckedUpdateWithoutEmployeeInput>
    create: XOR<FinalSettlementCreateWithoutEmployeeInput, FinalSettlementUncheckedCreateWithoutEmployeeInput>
  }

  export type FinalSettlementUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: FinalSettlementWhereUniqueInput
    data: XOR<FinalSettlementUpdateWithoutEmployeeInput, FinalSettlementUncheckedUpdateWithoutEmployeeInput>
  }

  export type FinalSettlementUpdateManyWithWhereWithoutEmployeeInput = {
    where: FinalSettlementScalarWhereInput
    data: XOR<FinalSettlementUpdateManyMutationInput, FinalSettlementUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type FinalSettlementScalarWhereInput = {
    AND?: FinalSettlementScalarWhereInput | FinalSettlementScalarWhereInput[]
    OR?: FinalSettlementScalarWhereInput[]
    NOT?: FinalSettlementScalarWhereInput | FinalSettlementScalarWhereInput[]
    id?: IntFilter<"FinalSettlement"> | number
    employeeId?: IntFilter<"FinalSettlement"> | number
    terminationDate?: DateTimeFilter<"FinalSettlement"> | Date | string
    terminationType?: StringFilter<"FinalSettlement"> | string
    lastWorkingDay?: DateTimeFilter<"FinalSettlement"> | Date | string
    yearsWorked?: FloatFilter<"FinalSettlement"> | number
    eosbAmount?: FloatFilter<"FinalSettlement"> | number
    unusedLeaveDays?: IntFilter<"FinalSettlement"> | number
    unusedLeavePay?: FloatFilter<"FinalSettlement"> | number
    otherDues?: FloatNullableFilter<"FinalSettlement"> | number | null
    totalSettlement?: FloatFilter<"FinalSettlement"> | number
    status?: StringFilter<"FinalSettlement"> | string
    approvedBy?: IntNullableFilter<"FinalSettlement"> | number | null
    approvedAt?: DateTimeNullableFilter<"FinalSettlement"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"FinalSettlement"> | Date | string | null
  }

  export type EmployeeCreateWithoutContractsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutContractsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutContractsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
  }

  export type EmployeeUpsertWithoutContractsInput = {
    update: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutContractsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeUpdateWithoutContractsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutContractsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutLeavesInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutTravelTicketsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTravelTicketsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTravelTicketsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTravelTicketsInput, EmployeeUncheckedCreateWithoutTravelTicketsInput>
  }

  export type EmployeeUpsertWithoutTravelTicketsInput = {
    update: XOR<EmployeeUpdateWithoutTravelTicketsInput, EmployeeUncheckedUpdateWithoutTravelTicketsInput>
    create: XOR<EmployeeCreateWithoutTravelTicketsInput, EmployeeUncheckedCreateWithoutTravelTicketsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTravelTicketsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTravelTicketsInput, EmployeeUncheckedUpdateWithoutTravelTicketsInput>
  }

  export type EmployeeUpdateWithoutTravelTicketsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTravelTicketsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAdvancesInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAdvancesInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAdvancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAdvancesInput, EmployeeUncheckedCreateWithoutAdvancesInput>
  }

  export type EmployeeUpsertWithoutAdvancesInput = {
    update: XOR<EmployeeUpdateWithoutAdvancesInput, EmployeeUncheckedUpdateWithoutAdvancesInput>
    create: XOR<EmployeeCreateWithoutAdvancesInput, EmployeeUncheckedCreateWithoutAdvancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAdvancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAdvancesInput, EmployeeUncheckedUpdateWithoutAdvancesInput>
  }

  export type EmployeeUpdateWithoutAdvancesInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAdvancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAssetsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAssetsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAssetsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAssetsInput, EmployeeUncheckedCreateWithoutAssetsInput>
  }

  export type EmployeeUpsertWithoutAssetsInput = {
    update: XOR<EmployeeUpdateWithoutAssetsInput, EmployeeUncheckedUpdateWithoutAssetsInput>
    create: XOR<EmployeeCreateWithoutAssetsInput, EmployeeUncheckedCreateWithoutAssetsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAssetsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAssetsInput, EmployeeUncheckedUpdateWithoutAssetsInput>
  }

  export type EmployeeUpdateWithoutAssetsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAttendancesInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendancesInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendancesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
  }

  export type EmployeeUpsertWithoutAttendancesInput = {
    update: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
    create: XOR<EmployeeCreateWithoutAttendancesInput, EmployeeUncheckedCreateWithoutAttendancesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendancesInput, EmployeeUncheckedUpdateWithoutAttendancesInput>
  }

  export type EmployeeUpdateWithoutAttendancesInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutEntitlementsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEntitlementsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEntitlementsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEntitlementsInput, EmployeeUncheckedCreateWithoutEntitlementsInput>
  }

  export type EmployeeUpsertWithoutEntitlementsInput = {
    update: XOR<EmployeeUpdateWithoutEntitlementsInput, EmployeeUncheckedUpdateWithoutEntitlementsInput>
    create: XOR<EmployeeCreateWithoutEntitlementsInput, EmployeeUncheckedCreateWithoutEntitlementsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEntitlementsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEntitlementsInput, EmployeeUncheckedUpdateWithoutEntitlementsInput>
  }

  export type EmployeeUpdateWithoutEntitlementsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEntitlementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutDocumentsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDocumentsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDocumentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type EmployeeUpsertWithoutDocumentsInput = {
    update: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeUpdateWithoutDocumentsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PayrollItemCreateWithoutPayrollRunInput = {
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
    employee: EmployeeCreateNestedOneWithoutPayrollItemsInput
  }

  export type PayrollItemUncheckedCreateWithoutPayrollRunInput = {
    id?: number
    employeeId: number
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
  }

  export type PayrollItemCreateOrConnectWithoutPayrollRunInput = {
    where: PayrollItemWhereUniqueInput
    create: XOR<PayrollItemCreateWithoutPayrollRunInput, PayrollItemUncheckedCreateWithoutPayrollRunInput>
  }

  export type PayrollItemCreateManyPayrollRunInputEnvelope = {
    data: PayrollItemCreateManyPayrollRunInput | PayrollItemCreateManyPayrollRunInput[]
  }

  export type PayrollItemUpsertWithWhereUniqueWithoutPayrollRunInput = {
    where: PayrollItemWhereUniqueInput
    update: XOR<PayrollItemUpdateWithoutPayrollRunInput, PayrollItemUncheckedUpdateWithoutPayrollRunInput>
    create: XOR<PayrollItemCreateWithoutPayrollRunInput, PayrollItemUncheckedCreateWithoutPayrollRunInput>
  }

  export type PayrollItemUpdateWithWhereUniqueWithoutPayrollRunInput = {
    where: PayrollItemWhereUniqueInput
    data: XOR<PayrollItemUpdateWithoutPayrollRunInput, PayrollItemUncheckedUpdateWithoutPayrollRunInput>
  }

  export type PayrollItemUpdateManyWithWhereWithoutPayrollRunInput = {
    where: PayrollItemScalarWhereInput
    data: XOR<PayrollItemUpdateManyMutationInput, PayrollItemUncheckedUpdateManyWithoutPayrollRunInput>
  }

  export type PayrollRunCreateWithoutItemsInput = {
    periodStart: Date | string
    periodEnd: Date | string
    status: string
    createdBy: number
    createdAt?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    totalGross?: number | null
    totalNet?: number | null
    totalDeductions?: number | null
  }

  export type PayrollRunUncheckedCreateWithoutItemsInput = {
    id?: number
    periodStart: Date | string
    periodEnd: Date | string
    status: string
    createdBy: number
    createdAt?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    totalGross?: number | null
    totalNet?: number | null
    totalDeductions?: number | null
  }

  export type PayrollRunCreateOrConnectWithoutItemsInput = {
    where: PayrollRunWhereUniqueInput
    create: XOR<PayrollRunCreateWithoutItemsInput, PayrollRunUncheckedCreateWithoutItemsInput>
  }

  export type EmployeeCreateWithoutPayrollItemsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    finalSettlements?: FinalSettlementCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPayrollItemsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    finalSettlements?: FinalSettlementUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPayrollItemsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayrollItemsInput, EmployeeUncheckedCreateWithoutPayrollItemsInput>
  }

  export type PayrollRunUpsertWithoutItemsInput = {
    update: XOR<PayrollRunUpdateWithoutItemsInput, PayrollRunUncheckedUpdateWithoutItemsInput>
    create: XOR<PayrollRunCreateWithoutItemsInput, PayrollRunUncheckedCreateWithoutItemsInput>
    where?: PayrollRunWhereInput
  }

  export type PayrollRunUpdateToOneWithWhereWithoutItemsInput = {
    where?: PayrollRunWhereInput
    data: XOR<PayrollRunUpdateWithoutItemsInput, PayrollRunUncheckedUpdateWithoutItemsInput>
  }

  export type PayrollRunUpdateWithoutItemsInput = {
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalGross?: NullableFloatFieldUpdateOperationsInput | number | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PayrollRunUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalGross?: NullableFloatFieldUpdateOperationsInput | number | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type EmployeeUpsertWithoutPayrollItemsInput = {
    update: XOR<EmployeeUpdateWithoutPayrollItemsInput, EmployeeUncheckedUpdateWithoutPayrollItemsInput>
    create: XOR<EmployeeCreateWithoutPayrollItemsInput, EmployeeUncheckedCreateWithoutPayrollItemsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayrollItemsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayrollItemsInput, EmployeeUncheckedUpdateWithoutPayrollItemsInput>
  }

  export type EmployeeUpdateWithoutPayrollItemsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayrollItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    finalSettlements?: FinalSettlementUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutFinalSettlementsInput = {
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceCreateNestedManyWithoutEmployeeInput
    assets?: AssetCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementCreateNestedManyWithoutEmployeeInput
    documents?: DocumentCreateNestedManyWithoutEmployeeInput
    user?: UserCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutFinalSettlementsInput = {
    id?: number
    employeeCode?: string | null
    name: string
    nameEn?: string | null
    nationalId: string
    email?: string | null
    phone?: string | null
    iqamaNumber?: string | null
    iqamaExpiry?: Date | string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    nationality?: string | null
    bankName?: string | null
    iban?: string | null
    workPermitNumber?: string | null
    workPermitExpiry?: Date | string | null
    medicalInsuranceExpiry?: Date | string | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    travelTickets?: TravelTicketUncheckedCreateNestedManyWithoutEmployeeInput
    advances?: AdvanceUncheckedCreateNestedManyWithoutEmployeeInput
    assets?: AssetUncheckedCreateNestedManyWithoutEmployeeInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    entitlements?: EntitlementUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutEmployeeInput
    user?: UserUncheckedCreateNestedOneWithoutEmployeeInput
    payrollItems?: PayrollItemUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutFinalSettlementsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutFinalSettlementsInput, EmployeeUncheckedCreateWithoutFinalSettlementsInput>
  }

  export type EmployeeUpsertWithoutFinalSettlementsInput = {
    update: XOR<EmployeeUpdateWithoutFinalSettlementsInput, EmployeeUncheckedUpdateWithoutFinalSettlementsInput>
    create: XOR<EmployeeCreateWithoutFinalSettlementsInput, EmployeeUncheckedCreateWithoutFinalSettlementsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutFinalSettlementsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutFinalSettlementsInput, EmployeeUncheckedUpdateWithoutFinalSettlementsInput>
  }

  export type EmployeeUpdateWithoutFinalSettlementsInput = {
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutFinalSettlementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaNumber?: NullableStringFieldUpdateOperationsInput | string | null
    iqamaExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitNumber?: NullableStringFieldUpdateOperationsInput | string | null
    workPermitExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    medicalInsuranceExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    travelTickets?: TravelTicketUncheckedUpdateManyWithoutEmployeeNestedInput
    advances?: AdvanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assets?: AssetUncheckedUpdateManyWithoutEmployeeNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    entitlements?: EntitlementUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    user?: UserUncheckedUpdateOneWithoutEmployeeNestedInput
    payrollItems?: PayrollItemUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ContractCreateManyEmployeeInput = {
    id?: number
    startDate: Date | string
    endDate?: Date | string | null
    salary: number
    leaveDays: number
    leaveMoney: number
    contractType: string
    probationDays?: number | null
    basicSalary?: number | null
    housingAllow?: number | null
    transportAllow?: number | null
  }

  export type LeaveCreateManyEmployeeInput = {
    id?: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    daysCount: number
    paid: boolean
    paidAmount?: number | null
    status: string
    requestDate?: Date | string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    rejectedReason?: string | null
    sickPayRate?: number | null
  }

  export type TravelTicketCreateManyEmployeeInput = {
    id?: number
    year: number
    issued?: boolean
    issueDate?: Date | string | null
  }

  export type AdvanceCreateManyEmployeeInput = {
    id?: number
    amount: number
    date: Date | string
    status: string
  }

  export type AssetCreateManyEmployeeInput = {
    id?: number
    assetType: string
    description?: string | null
    assignedDate: Date | string
    returned?: boolean
    returnDate?: Date | string | null
  }

  export type AttendanceCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    checkIn?: Date | string | null
    checkOut?: Date | string | null
  }

  export type EntitlementCreateManyEmployeeInput = {
    id?: number
    yearsWorked?: number | null
    fraction?: number | null
    terminationType?: string | null
    paid?: boolean
    paidDate?: Date | string | null
    type: string
    amount: number
    calculatedAt: Date | string
  }

  export type DocumentCreateManyEmployeeInput = {
    id?: number
    docType: string
    expiryDate: Date | string
    number?: string | null
  }

  export type PayrollItemCreateManyEmployeeInput = {
    id?: number
    payrollRunId: number
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
  }

  export type FinalSettlementCreateManyEmployeeInput = {
    id?: number
    terminationDate: Date | string
    terminationType: string
    lastWorkingDay: Date | string
    yearsWorked: number
    eosbAmount: number
    unusedLeaveDays: number
    unusedLeavePay: number
    otherDues?: number | null
    totalSettlement: number
    status: string
    approvedBy?: number | null
    approvedAt?: Date | string | null
    paidDate?: Date | string | null
  }

  export type ContractUpdateWithoutEmployeeInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ContractUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: FloatFieldUpdateOperationsInput | number
    leaveDays?: IntFieldUpdateOperationsInput | number
    leaveMoney?: FloatFieldUpdateOperationsInput | number
    contractType?: StringFieldUpdateOperationsInput | string
    probationDays?: NullableIntFieldUpdateOperationsInput | number | null
    basicSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveUpdateWithoutEmployeeInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCount?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedReason?: NullableStringFieldUpdateOperationsInput | string | null
    sickPayRate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TravelTicketUpdateWithoutEmployeeInput = {
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TravelTicketUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TravelTicketUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    issued?: BoolFieldUpdateOperationsInput | boolean
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdvanceUpdateWithoutEmployeeInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AdvanceUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AdvanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AssetUpdateWithoutEmployeeInput = {
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returned?: BoolFieldUpdateOperationsInput | boolean
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EntitlementUpdateWithoutEmployeeInput = {
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitlementUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    yearsWorked?: NullableFloatFieldUpdateOperationsInput | number | null
    fraction?: NullableFloatFieldUpdateOperationsInput | number | null
    terminationType?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutEmployeeInput = {
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    docType?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayrollItemUpdateWithoutEmployeeInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payrollRun?: PayrollRunUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PayrollItemUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    payrollRunId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayrollItemUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    payrollRunId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinalSettlementUpdateWithoutEmployeeInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinalSettlementUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FinalSettlementUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationType?: StringFieldUpdateOperationsInput | string
    lastWorkingDay?: DateTimeFieldUpdateOperationsInput | Date | string
    yearsWorked?: FloatFieldUpdateOperationsInput | number
    eosbAmount?: FloatFieldUpdateOperationsInput | number
    unusedLeaveDays?: IntFieldUpdateOperationsInput | number
    unusedLeavePay?: FloatFieldUpdateOperationsInput | number
    otherDues?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSettlement?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollItemCreateManyPayrollRunInput = {
    id?: number
    employeeId: number
    basicSalary: number
    housingAllow?: number | null
    transportAllow?: number | null
    otherAllow?: number | null
    overtimePay?: number | null
    grossPay: number
    advanceDeduction?: number | null
    loanDeduction?: number | null
    unpaidLeaveDeduction?: number | null
    otherDeductions?: number | null
    totalDeductions: number
    netPay: number
    iban?: string | null
    wpsStatus?: string | null
  }

  export type PayrollItemUpdateWithoutPayrollRunInput = {
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutPayrollItemsNestedInput
  }

  export type PayrollItemUncheckedUpdateWithoutPayrollRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayrollItemUncheckedUpdateManyWithoutPayrollRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    basicSalary?: FloatFieldUpdateOperationsInput | number
    housingAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    transportAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    otherAllow?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimePay?: NullableFloatFieldUpdateOperationsInput | number | null
    grossPay?: FloatFieldUpdateOperationsInput | number
    advanceDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    unpaidLeaveDeduction?: NullableFloatFieldUpdateOperationsInput | number | null
    otherDeductions?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDeductions?: FloatFieldUpdateOperationsInput | number
    netPay?: FloatFieldUpdateOperationsInput | number
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    wpsStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EmployeeCountOutputTypeDefaultArgs instead
     */
    export type EmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollRunCountOutputTypeDefaultArgs instead
     */
    export type PayrollRunCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollRunCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeDefaultArgs instead
     */
    export type EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveDefaultArgs instead
     */
    export type LeaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TravelTicketDefaultArgs instead
     */
    export type TravelTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TravelTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvanceDefaultArgs instead
     */
    export type AdvanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceDefaultArgs instead
     */
    export type AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntitlementDefaultArgs instead
     */
    export type EntitlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntitlementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollRunDefaultArgs instead
     */
    export type PayrollRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollRunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollItemDefaultArgs instead
     */
    export type PayrollItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinalSettlementDefaultArgs instead
     */
    export type FinalSettlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinalSettlementDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}